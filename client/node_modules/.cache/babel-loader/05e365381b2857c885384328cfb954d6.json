{"ast":null,"code":"import { useIsomorphicLayoutEffect, each, is, toArray, isFluidValue, needsInterpolation, isEqual, usePrev, useOnce, useForceUpdate, Globals } from '@react-spring/shared';\nexport { Globals, createInterpolator, isFluidValue, makeFluidValue } from '@react-spring/shared';\nimport React, { useMemo as useMemo$1, useImperativeHandle, useRef } from 'react';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { frameLoop, createStringInterpolator, now, skipAnimation, requestAnimationFrame, performanceNow } from '@react-spring/shared/globals';\nimport { useMemoOne } from 'use-memo-one';\nimport { AnimationValue, isAnimationValue, AnimatedString, AnimatedValue, AnimatedArray, Into } from '@react-spring/animated';\nexport { AnimationValue, Into, isAnimationValue } from '@react-spring/animated';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport { deprecateInterpolate } from '@react-spring/shared/deprecations';\nimport { createStringInterpolator as createStringInterpolator$1 } from '@react-spring/shared/stringInterpolation';\n/** API\n *  useChain(references, timeSteps, timeFrame)\n */\n\nfunction useChain(refs, timeSteps, timeFrame) {\n  if (timeFrame === void 0) {\n    timeFrame = 1000;\n  }\n\n  useIsomorphicLayoutEffect(() => {\n    if (timeSteps) {\n      let prevDelay = 0;\n      each(refs, (ref, i) => {\n        if (!ref.current) return;\n        const controllers = ref.current.controllers;\n\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i]; // Use the previous delay if none exists.\n\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n          each(controllers, ctrl => {\n            each(ctrl.queue, props => {\n              props.delay = delay + (props.delay || 0);\n            });\n            ctrl.start();\n          });\n        }\n      });\n    } else {\n      let p = Promise.resolve();\n      each(refs, ref => {\n        const _ref = ref.current || {},\n              controllers = _ref.controllers,\n              start = _ref.start;\n\n        if (controllers && controllers.length) {\n          // Take the queue of each controller\n          const updates = controllers.map(ctrl => {\n            const q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          }); // Apply the queue when the previous ref stops animating\n\n          p = p.then(() => {\n            each(controllers, (ctrl, i) => ctrl.queue.push(...updates[i]));\n            return start();\n          });\n        }\n      });\n    }\n  });\n}\n\nconst useMemo = (create, deps) => useMemoOne(create, deps || [{}]);\n\nfunction callProp(value) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return is.fun(value) ? value(...args) : value;\n}\n/** Try to coerce the given value into a boolean using the given key */\n\n\nconst matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));\n\nconst getProps = (props, i, arg) => is.fun(props) ? props(i, arg) : is.arr(props) ? props[i] : _extends({}, props);\n/** These props can have default values */\n\n\nconst DEFAULT_PROPS = ['config', 'immediate', 'onAnimate', 'onStart', 'onChange', 'onRest'];\nconst RESERVED_PROPS = {\n  children: 1,\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  reset: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  lazy: 1,\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  leave: 1,\n  update: 1,\n  onAnimate: 1,\n  onStart: 1,\n  onRest: 1,\n  onChange: 1,\n  onFrame: 1\n};\n/**\r\n * Extract any properties whose keys are *not* reserved for customizing your\r\n * animations. All hooks use this function, which means `useTransition` props\r\n * are reserved for `useSpring` calls, etc.\r\n */\n\nfunction getForwardProps(props) {\n  const forward = {};\n  each(props, (value, prop) => {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n    }\n  });\n  return forward;\n}\n\nfunction interpolateTo(props) {\n  const to = getForwardProps(props);\n  const out = {\n    to\n  };\n  each(props, (val, key) => key in to || (out[key] = val));\n  return out;\n}\n/**\r\n * Start an async chain or an async script.\r\n *\r\n * You should always wrap `runAsync` calls with `scheduleProps` so that\r\n * you have access to `RunAsyncProps` instead of the usual `SpringProps`.\r\n *\r\n * The `T` parameter can be a set of animated values (as an object type)\r\n * or a primitive type for a single animated value.\r\n */\n\n\nasync function runAsync(to, props, state, getValue, getPaused, update, stop) {\n  if (props.cancel) {\n    state.asyncTo = undefined;\n    return {\n      value: getValue(),\n      cancelled: true\n    };\n  } // Wait for the previous async animation to be cancelled.\n  else if (props.reset) {\n      await state.promise;\n    } // Async animations are only replaced when \"props.to\" changes\n    // or when \"props.reset\" equals true.\n    else if (to === state.asyncTo) {\n        return state.promise;\n      }\n\n  state.asyncTo = to;\n  return state.promise = (async () => {\n    const asyncId = props.asyncId;\n    const cancelToken = Symbol.for('cancel');\n\n    const isCancelled = () => to !== state.asyncTo || asyncId <= (state.cancelId || 0);\n\n    const defaultProps = {};\n    each(DEFAULT_PROPS, prop => {\n      if (prop == 'onRest') return;\n\n      if (/function|object/.test(typeof props[prop])) {\n        defaultProps[prop] = props[prop];\n      }\n    });\n\n    const animate = (arg1, arg2) => {\n      if (isCancelled()) {\n        throw cancelToken;\n      }\n\n      const props = is.obj(arg1) ? _extends({}, arg1) : _extends({}, arg2, {\n        to: arg1\n      });\n      each(defaultProps, (value, prop) => {\n        if (is.und(props[prop])) {\n          props[prop] = value;\n        }\n      });\n      const parentTo = state.asyncTo;\n      return update(props).then(async result => {\n        if (state.asyncTo == null) {\n          state.asyncTo = parentTo;\n        }\n\n        if (isCancelled()) {\n          throw cancelToken;\n        }\n\n        if (getPaused()) {\n          await new Promise(resolve => {\n            state.unpause = resolve;\n          });\n          state.unpause = undefined;\n        }\n\n        return result;\n      });\n    };\n\n    let result;\n\n    try {\n      // Async sequence\n      if (is.arr(to)) {\n        for (const props of to) {\n          await animate(props);\n        }\n      } // Async script\n      else if (is.fun(to)) {\n          await to(animate, stop);\n        }\n\n      result = {\n        value: getValue(),\n        finished: true\n      };\n    } catch (err) {\n      if (err !== cancelToken) {\n        throw err;\n      }\n\n      result = {\n        value: getValue(),\n        cancelled: true\n      };\n    } finally {\n      state.promise = undefined;\n\n      if (to == state.asyncTo) {\n        state.asyncTo = undefined;\n      }\n    }\n\n    if (props.onRest) {\n      props.onRest(result);\n    }\n\n    return result;\n  })();\n} //\n// scheduleProps(props, state, action)\n//\n\n/**\r\n * Pass props to your action when any delay is finished and the\r\n * props weren't cancelled before then.\r\n */\n\n\nfunction scheduleProps(asyncId, props, state, action) {\n  return new Promise((resolve, reject) => {\n    let delay = props.delay,\n        cancel = props.cancel,\n        reset = props.reset;\n\n    if (is.num(delay) && delay > 0) {\n      setTimeout(run, delay);\n    } else run();\n\n    function run() {\n      // Might be cancelled during delay.\n      if (asyncId <= (state.cancelId || 0)) {\n        cancel = true;\n      } else {\n        cancel = matchProp(cancel, state.key);\n\n        if (cancel) {\n          state.cancelId = asyncId;\n        }\n      }\n\n      reset = !cancel && matchProp(reset, state.key);\n\n      try {\n        action(_extends({}, props, {\n          asyncId,\n          cancel,\n          reset\n        }), resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n} // The `mass` prop defaults to 1\n\n\nconst config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n/** The spring cannot be animated */\n\nconst DISPOSED = 'DISPOSED';\n/** The spring has not animated yet */\n\nconst CREATED = 'CREATED';\n/** The spring has animated before */\n\nconst IDLE = 'IDLE';\n/** The spring is frozen in time */\n\nconst PAUSED = 'PAUSED';\n/** The spring is animating */\n\nconst ACTIVE = 'ACTIVE';\n\nconst noop = () => {};\n\nconst BASE_CONFIG = _extends({}, config.default, {\n  mass: 1,\n  velocity: 0,\n  progress: 0,\n  easing: t => t,\n  clamp: false\n});\n/** An opaque animatable value */\n\n\nclass SpringValue extends AnimationValue {\n  constructor(key) {\n    super(key);\n    /** The animation state */\n\n    this.animation = {\n      value: this\n    };\n    /** The lifecycle phase of this spring */\n\n    this._phase = CREATED;\n    /** The last time each prop changed */\n\n    this._timestamps = {};\n    /** Some props have customizable default values */\n\n    this._defaultProps = {};\n    /** Cancel any update from before this timestamp */\n\n    this._lastAsyncId = 0;\n    this._state = {\n      key\n    };\n  }\n\n  get idle() {\n    return !this.is(ACTIVE);\n  }\n  /** Check the current phase */\n\n\n  is(phase) {\n    return this._phase == phase;\n  }\n  /** Set the current value, while stopping the current animation */\n\n\n  set(value) {\n    if (this._set(value) && this.idle) {\n      // Since \"_stop\" calls \"_onChange\" only when not idle, we need this.\n      this._onChange(this.get(), true);\n    }\n\n    this._stop();\n\n    return this;\n  }\n  /**\r\n   * Freeze the active animation in time.\r\n   * This does nothing when not animating.\r\n   *\r\n   * Call `start` to unpause.\r\n   */\n\n\n  pause() {\n    checkDisposed(this, 'pause');\n\n    if (!this.idle) {\n      this._phase = PAUSED;\n      frameLoop.stop(this);\n    }\n  }\n  /**\r\n   * Skip to the end of the current animation.\r\n   *\r\n   * All `onRest` callbacks are passed `{finished: true}`\r\n   */\n\n\n  finish(to) {\n    if (!this.idle) {\n      const anim = this.animation; // Decay animations have an implicit goal.\n\n      if (!anim.config.decay && is.und(to)) {\n        to = anim.to;\n      } // Set the value if we can.\n\n\n      if (!is.und(to)) {\n        this._set(to);\n      } // Exit the frameloop.\n\n\n      this._stop(true);\n    }\n\n    return this;\n  }\n  /** Push props into the pending queue. */\n\n\n  update(props) {\n    checkDisposed(this, 'update'); // Ensure the initial value can be accessed by animated components.\n\n    this.setNodeWithProps(props);\n    const queue = this.queue || (this.queue = []);\n    queue.push(props);\n    return this;\n  }\n\n  async start(to, arg2) {\n    checkDisposed(this, 'start'); // Unpause if possible.\n\n    if (this.is(PAUSED)) {\n      this._start();\n\n      if (this._state.asyncTo) {\n        this._state.unpause();\n      }\n    }\n\n    let queue;\n\n    if (!is.und(to)) {\n      queue = [is.obj(to) ? to : _extends({}, arg2, {\n        to\n      })];\n    } else {\n      queue = this.queue || [];\n      this.queue = [];\n    }\n\n    await Promise.all(queue.map(props => this._animate(props)));\n    return {\n      finished: true,\n      value: this.get(),\n      spring: this\n    };\n  }\n  /**\r\n   * Stop the current animation, and cancel any delayed updates.\r\n   */\n\n\n  stop() {\n    if (!this.is(DISPOSED)) {\n      this._state.cancelId = this._lastAsyncId;\n\n      this._to(this.get());\n\n      this._stop();\n    }\n\n    return this;\n  }\n  /** Restart the animation. */\n\n\n  reset() {\n    this._animate({\n      reset: true\n    });\n  }\n  /** Prevent future animations, and stop the current animation */\n\n\n  dispose() {\n    if (!this.is(DISPOSED)) {\n      if (this.animation) {\n        // Prevent \"onRest\" calls when disposed.\n        this.animation.onRest = undefined;\n      }\n\n      this.stop();\n      this._phase = DISPOSED;\n    }\n  }\n  /** Observe value changes. To stop observing, call the returned function. */\n\n\n  onChange(fn) {\n    this._children.add(fn);\n\n    return () => this._children.delete(fn);\n  }\n  /** @internal */\n\n\n  onParentChange(value, idle) {\n    const anim = this.animation; // The \"FrameLoop\" handles everything other than immediate animation.\n\n    if (anim.immediate) {\n      if (idle) {\n        this.finish(value);\n      } else {\n        this._set(value);\n      }\n    } // When our parent is not a spring, it won't tell us to enter the frameloop\n    // because it never does so itself. Instead, we must react to value changes.\n    else if (this.idle) {\n        anim.fromValues = anim.values.map(node => node.lastPosition);\n\n        this._start();\n      }\n  }\n  /** @internal Called by the frameloop */\n\n\n  onFrame(idle, changed) {\n    if (idle) {\n      this.finish();\n    } else if (changed) {\n      this._onChange(this.get());\n    }\n  }\n  /**\r\n   * @internal\r\n   * Analyze the given `value` to determine which data type is being animated.\r\n   * Then, create an `Animated` node for that data type and make it our `node`.\r\n   */\n\n\n  setNodeWithValue(value) {\n    if (value != null) {\n      this.node = this._getNodeType(value).create(computeGoal(value));\n    }\n  }\n  /**\r\n   * @internal\r\n   * Analyze the given `props` to determine which data type is being animated.\r\n   * Then, create an `Animated` node for that data type and make it our `node`.\r\n   * If we already have a `node`, do nothing but return the `{from, to}` range.\r\n   */\n\n\n  setNodeWithProps(props) {\n    const range = this._getRange(props);\n\n    if (!this.node) {\n      this.setNodeWithValue(range.from != null ? range.from : range.to);\n    }\n\n    return range;\n  }\n  /** Return the `Animated` node constructor for a given value */\n\n\n  _getNodeType(value) {\n    const parent = isAnimationValue(value) ? value : null;\n    const parentType = parent && parent.node && parent.node.constructor;\n\n    if (!parent && isFluidValue(value)) {\n      value = value.get();\n    }\n\n    return parentType == AnimatedString ? AnimatedValue : parentType || (is.arr(value) ? AnimatedArray : needsInterpolation(value) ? AnimatedString : AnimatedValue);\n  }\n  /** Pluck the `to` and `from` props */\n\n\n  _getRange(props) {\n    const to = props.to,\n          from = props.from;\n    const key = this.key || '';\n    return {\n      to: !is.obj(to) || isFluidValue(to) ? to : to[key],\n      from: !is.obj(from) || isFluidValue(from) ? from : from[key]\n    };\n  }\n  /** Update this value's animation using the given props. */\n\n\n  _animate(props) {\n    // Ensure the initial value can be accessed by animated components.\n    const range = this.setNodeWithProps(props);\n    const timestamp = now();\n    return scheduleProps(++this._lastAsyncId, props, this._state, (props, resolve) => {\n      const to = props.to;\n\n      if (is.arr(to) || is.fun(to)) {\n        resolve(runAsync(to, props, this._state, () => this.get(), () => this.is(PAUSED), this.start.bind(this), this.stop.bind(this)));\n      } else if (props.cancel) {\n        this.stop();\n        resolve({\n          value: this.get(),\n          cancelled: true\n        });\n      } else {\n        this._update(range, props, timestamp, resolve);\n      }\n    });\n  }\n  /** Update the internal `animation` object */\n\n\n  _update(_ref, props, timestamp, resolve) {\n    let to = _ref.to,\n        from = _ref.from;\n    const defaultProps = this._defaultProps;\n    /** Get the value of a prop, or its default value */\n\n    const get = prop => !is.und(props[prop]) ? props[prop] : defaultProps[prop];\n\n    const onAnimate = get('onAnimate');\n\n    if (onAnimate) {\n      onAnimate(props, this);\n    } // Cast from a partial type.\n\n\n    const anim = this.animation;\n    const timestamps = this._timestamps;\n    /** Return true if our prop can be used. This only affects delayed props. */\n\n    const diff = prop => {\n      if (timestamp >= (timestamps[prop] || 0)) {\n        timestamps[prop] = timestamp;\n        return true;\n      }\n\n      return false;\n    };\n\n    const prevTo = anim.to,\n          prevFrom = anim.from; // The \"reverse\" prop only affects one update.\n\n    if (props.reverse) {\n      var _ref2 = [from, to];\n      to = _ref2[0];\n      from = _ref2[1];\n    }\n\n    if (!is.und(to) && diff('to')) {\n      this._to(to);\n    } else {\n      to = prevTo;\n    }\n\n    if (!is.und(from) && diff('from')) {\n      anim.from = from;\n    } else {\n      from = anim.from;\n    }\n\n    if (isFluidValue(from)) {\n      from = from.get();\n    }\n\n    const reset = props.reset && !is.und(from);\n    const changed = !is.und(to) && !isEqual(to, prevTo);\n    const parent = isFluidValue(to) && to;\n    /** The current value */\n\n    let value = reset ? from : this.get();\n\n    if (is.und(from)) {\n      from = value;\n    }\n    /** When true, this spring must be in the frameloop. */\n\n\n    let started = !!parent || (changed || reset) && !isEqual(value, to);\n    /** The initial velocity before this `animate` call. */\n\n    const lastVelocity = anim.config ? anim.config.velocity : 0; // The \"config\" prop either overwrites or merges into the existing config.\n\n    let config = props.config;\n\n    if (config || started || !anim.config) {\n      const key = this.key || '';\n      config = _extends({}, callProp(defaultProps.config, key), callProp(config, key));\n\n      if (!started && canMergeConfigs(config, anim.config)) {\n        Object.assign(anim.config, config);\n      } else {\n        anim.config = config = _extends({}, BASE_CONFIG, config);\n      } // Derive \"tension\" and \"friction\" from \"frequency\" and \"damping\".\n\n\n      if (!is.und(config.frequency)) {\n        const damping = is.und(config.damping) ? 1 : config.damping;\n        config.tension = Math.pow(config.frequency, 2) * config.mass;\n        config.friction = damping * Math.sqrt(config.tension * config.mass) / 0.5;\n      } // Cache the angular frequency in rad/ms\n\n\n      config.w0 = Math.sqrt(config.tension / config.mass) / 1000;\n    } else {\n      config = anim.config;\n    } // Always start animations with velocity.\n\n\n    if (!started && (config.decay || !is.und(to))) {\n      started = !isEqual(config.velocity, lastVelocity);\n    } // Reset our internal `Animated` node if starting.\n\n\n    let node = this.node;\n    let nodeType;\n\n    if (changed) {\n      nodeType = this._getNodeType(to);\n\n      if (nodeType !== node.constructor) {\n        throw Error(`Cannot animate to the given \"to\" prop, because the current value has a different type`);\n      }\n    } else {\n      nodeType = node.constructor;\n    } // The final value of our animation, excluding the \"to\" value.\n    // The \"FrameLoop\" decides our goal value when \"parent\" exists.\n\n\n    let goal = parent ? null : computeGoal(to);\n\n    if (nodeType == AnimatedString) {\n      from = 0;\n      goal = 1;\n    } // Ensure the current value equals the \"from\" value when reset\n    // and when the \"from\" value is updated before the first animation.\n\n\n    if (reset || this.is(CREATED) && !is.und(anim.from) && !isEqual(anim.from, prevFrom)) {\n      node.setValue(value = from);\n    } // Event props are replaced on every update.\n\n\n    anim.onStart = get('onStart');\n    anim.onChange = get('onChange'); // Update the default props.\n\n    if (props.default) {\n      each(DEFAULT_PROPS, prop => {\n        // Default props can only be null, an object, or a function.\n        if (/function|object/.test(typeof props[prop])) {\n          defaultProps[prop] = props[prop];\n        }\n      });\n    }\n\n    if (!started) {\n      // Resolve the \"animate\" promise.\n      return resolve({\n        value,\n        spring: this,\n        finished: true\n      });\n    } // This must come *before* \"fromValues\" is set,\n    // because it updates \"node.lastPosition\"\n\n\n    this._reset();\n\n    anim.values = node.getPayload();\n    anim.toValues = parent ? null : toArray(goal);\n    anim.fromValues = anim.values.map(node => node.lastPosition);\n    anim.immediate = !(parent || is.num(goal) || is.arr(goal)) || !!matchProp(get('immediate'), this.key);\n    const onRestQueue = anim.onRest; // The \"onRest\" prop is always first in the queue.\n\n    anim.onRest = [get('onRest') || noop, resolve]; // Resolve the promise for unfinished animations.\n\n    if (onRestQueue && onRestQueue.length > 1) {\n      const result = {\n        value,\n        spring: this,\n        cancelled: true\n      }; // Skip the \"onRest\" prop, as the animation is still active.\n\n      for (let i = 1; i < onRestQueue.length; i++) {\n        onRestQueue[i](result);\n      }\n    }\n\n    this._start();\n  }\n  /** Update the `animation.to` value, which might be a `FluidValue` */\n\n\n  _to(value) {\n    const anim = this.animation;\n\n    if (isFluidValue(anim.to)) {\n      if (value == anim.to) return;\n      anim.to.removeChild(this);\n    }\n\n    anim.to = value;\n\n    if (isFluidValue(value)) {\n      value.addChild(this);\n      this.priority = (value.priority || 0) + 1;\n    } else {\n      this.priority = 0;\n    }\n  }\n  /** Set the current value and our `node` if necessary. The `_onChange` method is *not* called. */\n\n\n  _set(value) {\n    if (isFluidValue(value)) {\n      value = value.get();\n    }\n\n    const node = this.node;\n\n    if (node) {\n      if (isEqual(value, node.getValue())) {\n        return false;\n      }\n\n      node.setValue(value);\n    } else {\n      this.setNodeWithValue(value);\n    }\n\n    return true;\n  }\n  /** Notify change observers */\n\n\n  _onChange(value, idle) {\n    if (idle === void 0) {\n      idle = false;\n    }\n\n    const anim = this.animation;\n\n    if (!anim.changed && !idle) {\n      anim.changed = true; // The \"onStart\" prop is called on the first change after entering the\n      // frameloop, but never for immediate animations.\n\n      if (anim.onStart) {\n        anim.onStart(this);\n      }\n    }\n\n    if (anim.onChange) {\n      anim.onChange(value, this);\n    }\n\n    super._onChange(value, idle);\n  }\n\n  _onPriorityChange(priority) {\n    if (!this.idle) {\n      // Re-enter the frameloop so our new priority is used.\n      frameLoop.stop(this).start(this);\n    }\n\n    super._onPriorityChange(priority);\n  }\n  /** Reset our node, and the nodes of every descendant spring */\n\n\n  _reset(goal) {\n    if (goal === void 0) {\n      goal = computeGoal(this.animation.to);\n    }\n\n    super._reset(goal);\n  }\n  /** Enter the frameloop */\n\n\n  _start() {\n    if (this.idle) {\n      this._phase = ACTIVE; // Animations without \"onRest\" cannot enter the frameloop.\n\n      const anim = this.animation;\n\n      if (anim.onRest) {\n        anim.changed = false; // The \"skipAnimation\" global avoids the frameloop.\n\n        if (skipAnimation) {\n          this.finish(anim.to);\n        } else {\n          frameLoop.start(this);\n        }\n      } // Tell animatable children to enter the frameloop.\n\n\n      each(this._children, child => {\n        if (child instanceof SpringValue) {\n          child._start();\n        }\n      });\n    }\n  }\n  /** Exit the frameloop and notify `onRest` listeners */\n\n\n  _stop(finished) {\n    if (finished === void 0) {\n      finished = false;\n    }\n\n    if (!this.idle) {\n      this._phase = IDLE; // Always let change observers know when a spring becomes idle.\n\n      this._onChange(this.get(), true);\n\n      const anim = this.animation;\n      const onRestQueue = anim.onRest; // Animations without \"onRest\" never enter the frameloop.\n\n      if (onRestQueue) {\n        frameLoop.stop(this);\n        each(anim.values, node => {\n          node.done = true;\n        }); // Preserve the \"onRest\" prop between animations.\n\n        anim.onRest = [onRestQueue[0]]; // Never call the \"onRest\" prop for immediate or no-op animations.\n\n        if (anim.immediate || !anim.changed) {\n          onRestQueue[0] = noop;\n        }\n\n        const result = {\n          value: this.get(),\n          spring: this,\n          finished\n        };\n        each(onRestQueue, onRest => onRest(result));\n      }\n    }\n  }\n\n} // TODO: makes this tree-shakeable\n\n\nfunction checkDisposed(spring, name) {\n  if (spring.is(DISPOSED)) {\n    throw Error(`Cannot call \"${name}\" of disposed \"${spring.constructor.name}\" object`);\n  }\n} // Merge configs when the existence of \"decay\" or \"duration\" has not changed.\n\n\nfunction canMergeConfigs(src, dest) {\n  return !!dest && is.und(src.decay) == is.und(dest.decay) && is.und(src.duration) == is.und(dest.duration);\n} // Compute the goal value, converting \"red\" to \"rgba(255, 0, 0, 1)\" in the process\n\n\nfunction computeGoal(value) {\n  return is.arr(value) ? value.map(computeGoal) : isFluidValue(value) ? computeGoal(value.get()) : needsInterpolation(value) ? createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\n\nlet nextId = 1;\nlet lastAsyncId = 0;\n\nclass Controller {\n  constructor(props) {\n    this.id = nextId++;\n    /** The values that changed in the last animation frame */\n\n    this.frame = {};\n    /** Fallback values for undefined props */\n\n    this.defaultProps = {};\n    /** The queue of pending props */\n\n    this.queue = [];\n    /** The current controller-only props (eg: `onFrame` and async state) */\n\n    this._props = {};\n    /** The spring values that manage their animations */\n\n    this._springs = {};\n    this._onChange = this._onChange.bind(this);\n    this._onFrame = this._onFrame.bind(this);\n\n    if (props) {\n      props.default = true;\n      this.start(props);\n    }\n  }\n  /** Equals true when no springs are animating */\n\n\n  get idle() {\n    return !this._props.promise && Object.values(this._springs).every(s => s.idle);\n  }\n  /** Get all existing `SpringValue` objects. This clones the internal store. */\n\n\n  get springs() {\n    return _extends({}, this._springs);\n  }\n\n  get(key) {\n    return this._springs[key];\n  }\n  /** Push an update onto the queue of each value. */\n\n\n  update(props) {\n    if (props) this.queue.push(this._update(props));\n    return this;\n  }\n  /**\r\n   * Start the queued animations for every spring, and resolve the returned\r\n   * promise once all queued animations have finished or been cancelled.\r\n   *\r\n   * When you pass a queue (instead of nothing), that queue is used instead of\r\n   * the queued animations added with the `update` method, which are left alone.\r\n   */\n\n\n  async start(queue) {\n    if (queue) {\n      queue = toArray(queue).map(props => this._update(props));\n    } else {\n      queue = this.queue;\n      this.queue = [];\n    }\n\n    const promises = [];\n    each(queue, props => {\n      const to = props.to,\n            onFrame = props.onFrame,\n            keys = props.keys;\n      const asyncTo = (is.arr(to) || is.fun(to)) && to;\n\n      if (asyncTo) {\n        props.to = undefined;\n      }\n\n      promises.push( // Send updates to every affected key.\n      ...keys.map(key => this._springs[key].start(props)), // Schedule controller-only props.\n      scheduleProps(++lastAsyncId, props, this._props, (props, resolve) => {\n        if (!props.cancel) {\n          // Never reuse \"onFrame\" from a previous update.\n          this._props.onFrame = onFrame || this.defaultProps.onFrame;\n\n          if (onFrame && props.default) {\n            this.defaultProps.onFrame = onFrame;\n          }\n        } // Start, replace, or cancel the async animation.\n\n\n        if (asyncTo) {\n          resolve(runAsync(asyncTo, props, this._props, this._get.bind(this), () => false, // TODO: add pausing to Controller\n          this.start.bind(this), this.stop.bind(this)));\n        } else {\n          resolve({\n            value: 0,\n            finished: !props.cancel\n          });\n        }\n      }));\n    });\n    const results = await Promise.all(promises);\n    return {\n      value: this._get(),\n      finished: results.every(result => result.finished)\n    };\n  }\n  /** Stop one animation, some animations, or all animations */\n\n\n  stop(keys) {\n    if (is.und(keys)) {\n      each(this._springs, spring => spring.stop());\n    } else {\n      each(toArray(keys), key => this._springs[key].stop());\n    }\n\n    return this;\n  }\n  /** Restart every animation. */\n\n\n  reset() {\n    each(this._springs, spring => spring.reset()); // TODO: restart async \"to\" prop\n\n    return this;\n  }\n  /** Destroy every spring in this controller */\n\n\n  dispose() {\n    this._props.asyncTo = undefined;\n    each(this._springs, spring => spring.dispose());\n    this._springs = {};\n  }\n  /** Get the current value of every spring */\n\n\n  _get() {\n    const values = {};\n    each(this._springs, (spring, key) => {\n      values[key] = spring.get();\n    });\n    return values;\n  }\n  /** Create a spring for every given key, and ensure they have `Animated` nodes. */\n\n\n  _setSprings(keys, from, to) {\n    each(keys, key => {\n      if (!this._springs[key]) {\n        const spring = this._springs[key] = new SpringValue(key);\n        spring.addChild(this._onChange);\n        spring.setNodeWithProps({\n          from,\n          to\n        });\n      }\n    });\n  }\n  /** Prepare an update with the given props. */\n\n\n  _update(propsArg) {\n    const props = interpolateTo(propsArg);\n    const keys = props.keys = extractKeys(props, this._springs);\n    let from = props.from,\n        to = props.to; // Avoid sending async \"to\" prop to springs.\n\n    if (is.arr(to) || is.fun(to)) {\n      to = undefined;\n    } // Create our springs and give them values.\n\n\n    if (from || to) {\n      this._setSprings(keys, from, to);\n    }\n\n    return props;\n  }\n  /** @internal Attached as an observer to every spring */\n\n\n  _onChange(value, spring) {\n    if (this._props.onFrame) {\n      this.frame[spring.key] = value;\n      frameLoop.onFrame(this._onFrame);\n    }\n  }\n  /** @internal Called at the end of every animation frame */\n\n\n  _onFrame() {\n    if (Object.keys(this.frame).length) {\n      this._props.onFrame(this.frame);\n\n      this.frame = {};\n    }\n  }\n\n}\n/** Determine which keys should receive an update */\n\n\nfunction extractKeys(props, springs) {\n  const keys = new Set();\n  /** Collect keys with a defined value */\n\n  const getDefinedKeys = obj => each(obj, (value, key) => {\n    if (!is.und(value)) {\n      keys.add(key);\n    }\n  });\n\n  const from = props.from,\n        to = props.to;\n  if (is.obj(to)) getDefinedKeys(to);\n  if (from) getDefinedKeys(from); // When neither \"from\" or \"to\" have a key with a defined value,\n  // return the keys for every existing spring.\n\n  return keys.size ? Array.from(keys) : Object.keys(springs);\n}\n/** @internal */\n\n\nfunction useSprings(length, props, deps) {\n  const propsFn = is.fun(props) && props;\n\n  if (propsFn && arguments.length < 3) {\n    deps = []; // Skip updates after first render.\n  } // The \"ref\" prop is taken from the props of the first spring only.\n  // The ref is assumed to *never* change after the first render.\n\n\n  let ref;\n  const ctrls = useMemo(() => [], []);\n  const updates = [];\n  const prevLength = usePrev(length) || 0;\n  useMemo(() => {\n    if (prevLength > length) {\n      for (let i = length; i < prevLength; i++) {\n        ctrls[i].dispose();\n      }\n    }\n\n    ctrls.length = length;\n\n    for (let i = 0; i < length; i++) {\n      const ctrl = ctrls[i] || (ctrls[i] = new Controller());\n      const update = propsFn ? propsFn(i, ctrl) : props[i];\n\n      if (update) {\n        update.default = true;\n\n        if (i == 0 && update.ref) {\n          ref = update.ref;\n        }\n\n        if (i < prevLength) {\n          updates[i] = update;\n        } else {\n          // Update new controllers immediately, so their\n          // spring values exist during first render.\n          ctrl.update(update);\n        }\n      }\n    }\n  }, deps);\n  const api = useMemo$1(() => ({\n    get controllers() {\n      return ctrls;\n    },\n\n    update: props => {\n      each(ctrls, (ctrl, i) => {\n        ctrl.update(getProps(props, i, ctrl));\n        if (!ref) ctrl.start();\n      });\n      return api;\n    },\n\n    async start() {\n      const results = await Promise.all(ctrls.map(ctrl => ctrl.start()));\n      return {\n        value: results.map(result => result.value),\n        finished: results.every(result => result.finished)\n      };\n    },\n\n    stop: keys => each(ctrls, ctrl => ctrl.stop(keys))\n  }), []);\n  useImperativeHandle(ref, () => api);\n  useIsomorphicLayoutEffect(() => {\n    each(updates, (update, i) => ctrls[i].update(update));\n\n    if (!ref) {\n      each(ctrls, ctrl => ctrl.start());\n    }\n  }, deps);\n  useOnce(() => () => {\n    each(ctrls, ctrl => ctrl.dispose());\n  });\n  const values = ctrls.map(ctrl => ctrl.springs);\n  return propsFn || arguments.length == 3 ? [values, api.update, api.stop] : values;\n}\n/** @internal */\n\n\nfunction useSpring(props, deps) {\n  const isFn = is.fun(props);\n\n  const _useSprings = useSprings(1, isFn ? props : [props], deps),\n        _useSprings$ = _useSprings[0],\n        values = _useSprings$[0],\n        update = _useSprings[1],\n        stop = _useSprings[2];\n\n  return isFn || arguments.length == 3 ? [values, update, stop] : values;\n}\n\nfunction useTrail(length, propsArg, deps) {\n  const propsFn = is.fun(propsArg) && propsArg;\n\n  if (propsFn && arguments.length < 3) {\n    deps = []; // Skip updates after first render.\n  }\n\n  const ctrls = [];\n  const result = useSprings(length, (i, ctrl) => {\n    ctrls[i] = ctrl;\n    return getProps(propsArg, i, ctrl);\n  }, deps);\n  useIsomorphicLayoutEffect(() => {\n    const reverse = is.obj(propsArg) && propsArg.reverse;\n\n    for (let i = 0; i < ctrls.length; i++) {\n      const parent = ctrls[i + (reverse ? 1 : -1)];\n      if (parent) ctrls[i].update({\n        to: parent.springs\n      }).start();\n    }\n  }, deps);\n  const update = result[1];\n\n  result[1] = propsArg => {\n    const reverse = is.obj(propsArg) && propsArg.reverse;\n    return update((i, ctrl) => {\n      const props = getProps(propsArg, i, ctrl);\n      const parent = ctrls[i + (reverse ? 1 : -1)];\n      if (parent) props.to = parent.springs;\n      return props;\n    });\n  };\n\n  return propsFn ? result : result[0];\n}\n/** This transition is being mounted */\n\n\nconst MOUNT = 0;\n/** This transition is entering or has entered */\n\nconst ENTER = 1;\n/** This transition had its animations updated */\n\nconst UPDATE = 2;\n/** This transition will expire after animating */\n\nconst LEAVE = 3;\n\nfunction getKeys(items, _ref) {\n  let key = _ref.key,\n      _ref$keys = _ref.keys,\n      keys = _ref$keys === void 0 ? key : _ref$keys;\n  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);\n}\n\nfunction useTransition(data, props, deps) {\n  const ref = props.ref,\n        reset = props.reset,\n        sort = props.sort,\n        _props$trail = props.trail,\n        trail = _props$trail === void 0 ? 0 : _props$trail,\n        _props$expires = props.expires,\n        expires = _props$expires === void 0 ? Infinity : _props$expires; // Every item has its own transition.\n\n  const items = toArray(data);\n  const transitions = []; // Keys help with reusing transitions between renders.\n  // The `key` prop can be undefined (which means the items themselves are used\n  // as keys), or a function (which maps each item to its key), or an array of\n  // keys (which are assigned to each item by index).\n\n  const keys = getKeys(items, props); // The \"onRest\" callbacks need a ref to the latest transitions.\n\n  const usedTransitions = useRef(null);\n  const prevTransitions = usedTransitions.current;\n  useIsomorphicLayoutEffect(() => {\n    usedTransitions.current = transitions;\n  }); // Destroy all transitions on dismount.\n\n  useOnce(() => () => each(usedTransitions.current, t => {\n    if (t.expiresBy != null) {\n      clearTimeout(t.expirationId);\n    }\n\n    t.ctrl.dispose();\n  })); // Map old indices to new indices.\n\n  const reused = [];\n  if (prevTransitions && !reset) each(prevTransitions, (t, i) => {\n    // Expired transitions are not rendered.\n    if (t.expiresBy != null) {\n      clearTimeout(t.expirationId);\n    } else {\n      i = reused[i] = keys.indexOf(t.key);\n      if (~i) transitions[i] = t;\n    }\n  }); // Mount new items with fresh transitions.\n\n  each(items, (item, i) => {\n    transitions[i] || (transitions[i] = {\n      key: keys[i],\n      item,\n      phase: MOUNT,\n      ctrl: new Controller()\n    });\n  }); // Update the item of any transition whose key still exists,\n  // and ensure leaving transitions are rendered until they finish.\n\n  if (reused.length) {\n    let i = -1;\n    each(reused, (keyIndex, prevIndex) => {\n      const t = prevTransitions[prevIndex];\n\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = _extends({}, t, {\n          item: items[keyIndex]\n        });\n      } else if (props.leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n\n  if (is.fun(sort)) {\n    transitions.sort((a, b) => sort(a.item, b.item));\n  } // Track cumulative delay for the \"trail\" prop.\n\n\n  let delay = -trail; // Expired transitions use this to dismount.\n\n  const forceUpdate = useForceUpdate();\n  const defaultProps = {};\n  each(DEFAULT_PROPS, prop => {\n    if (/function|object/.test(typeof props[prop])) {\n      defaultProps[prop] = props[prop];\n    }\n  }); // Generate changes to apply in useEffect.\n\n  const changes = new Map();\n  each(transitions, (t, i) => {\n    let to;\n    let from;\n    let phase;\n\n    if (t.phase == MOUNT) {\n      to = props.enter;\n      phase = ENTER; // The \"initial\" prop is only used on first render. It always overrides\n      // the \"from\" prop when defined, and it makes \"enter\" instant when null.\n\n      from = props.initial;\n\n      if (is.und(from) || prevTransitions && !reset) {\n        from = props.from;\n      }\n    } else {\n      const isLeave = keys.indexOf(t.key) < 0;\n\n      if (t.phase < LEAVE) {\n        if (isLeave) {\n          to = props.leave;\n          phase = LEAVE;\n        } else if (to = props.update) {\n          phase = UPDATE;\n        } else return;\n      } else if (!isLeave) {\n        to = props.enter;\n        phase = ENTER;\n      } else return;\n    } // The payload is used to update the spring props once the current render is committed.\n\n\n    const payload = _extends({}, defaultProps, {\n      // When \"to\" is a function, it can return (1) an array of \"useSpring\" props,\n      // (2) an async function, or (3) an object with any \"useSpring\" props.\n      to: to = callProp(to, t.item, i),\n      from: callProp(from, t.item, i),\n      delay: delay += trail,\n      config: callProp(props.config || defaultProps.config, t.item, i)\n    }, is.obj(to) && interpolateTo(to));\n\n    const onRest = payload.onRest;\n\n    payload.onRest = result => {\n      if (is.fun(onRest)) {\n        onRest(result);\n      }\n\n      if (t.phase == LEAVE && t.ctrl.idle) {\n        t.expiresBy = now() + expires;\n\n        if (expires <= 0) {\n          forceUpdate();\n        } else {\n          // Postpone dismounts while other controllers are active.\n          const transitions = usedTransitions.current;\n\n          if (transitions.every(t => t.ctrl.idle)) {\n            forceUpdate();\n          } // When `expires` is infinite, postpone dismount until next render.\n          else if (expires < Infinity) {\n              t.expirationId = setTimeout(forceUpdate, expires);\n            }\n        }\n      }\n    };\n\n    const change = {\n      phase\n    };\n    changes.set(t, change); // To ensure all Animated nodes exist during render,\n    // the payload must be applied immediately for new items.\n\n    if (t.phase > MOUNT) {\n      change.payload = payload;\n    } else {\n      t.ctrl.update(payload);\n    }\n  });\n  const api = useMemo$1(() => ({\n    get controllers() {\n      return usedTransitions.current.map(t => t.ctrl);\n    },\n\n    update(props) {\n      each(usedTransitions.current, (t, i) => t.ctrl.update(is.fun(props) ? props(i, t.ctrl) : is.arr(props) ? props[i] : props));\n      return api;\n    },\n\n    async start() {\n      const transitions = usedTransitions.current;\n      const results = await Promise.all(transitions.map(t => t.ctrl.start()));\n      return {\n        value: results.map(result => result.value),\n        finished: results.every(result => result.finished)\n      };\n    },\n\n    stop: keys => each(usedTransitions.current, t => t.ctrl.stop(keys))\n  }), []);\n  useImperativeHandle(ref, () => api);\n  useIsomorphicLayoutEffect(() => {\n    each(changes, (_ref2, t) => {\n      let phase = _ref2.phase,\n          payload = _ref2.payload;\n      t.phase = phase;\n      if (payload) t.ctrl.update(payload);\n      if (!ref) t.ctrl.start();\n    });\n  }, reset ? void 0 : deps);\n  return render => transitions.map(t => {\n    const elem = render(t.ctrl.springs, t.item, t);\n    return elem && elem.type ? React.createElement(elem.type, Object.assign({}, elem.props, {\n      key: is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id,\n      ref: elem.ref\n    })) : elem;\n  });\n}\n\nfunction Spring(_ref) {\n  let children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  return children(useSpring(props));\n}\n\nfunction Trail(_ref2) {\n  let items = _ref2.items,\n      children = _ref2.children,\n      props = _objectWithoutPropertiesLoose(_ref2, [\"items\", \"children\"]);\n\n  const trails = useTrail(items.length, props);\n  return items.map((item, index) => {\n    const result = children(item, index);\n    return is.fun(result) ? result(trails[index]) : result;\n  });\n}\n\nfunction Transition(_ref3) {\n  let items = _ref3.items,\n      children = _ref3.children,\n      props = _objectWithoutPropertiesLoose(_ref3, [\"items\", \"children\"]);\n\n  return useTransition(items, props)(children);\n}\n/** Map the value of one or more dependencies */\n\n\nconst to = function to(source) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return new Into(source, args);\n};\n/** @deprecated Use the `to` export instead */\n\n\nconst interpolate = function interpolate(source) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  return deprecateInterpolate(), new Into(source, args);\n};\n\nclass FrameLoop {\n  constructor(_temp) {\n    let _ref = _temp === void 0 ? {} : _temp,\n        update = _ref.update,\n        requestFrame = _ref.requestFrame;\n    /**\r\n     * The animated springs\r\n     */\n\n\n    this.springs = [];\n    /**\r\n     * True when at least one spring is animating.\r\n     */\n\n    this.active = false;\n    /** Equals true when a frame is being processed. */\n\n    this.updating = false;\n    /** Equals true when writing to native attributes. */\n\n    this.writing = false; // These queues are swapped at the end of every frame,\n    // after the current queue is drained.\n\n    this._queues = [new Set(), new Set()];\n    /** `onWrite` callbacks are flushed on every frame, after `onFrame` callbacks are flushed. */\n\n    this._writes = new Set();\n\n    this._requestFrame = // The global `requestAnimationFrame` must be dereferenced to avoid \"Illegal invocation\" errors\n    requestFrame || (fn => (0, requestAnimationFrame)(fn));\n\n    this.update = update && update.bind(this) || (time => {\n      if (!this.active) {\n        return false;\n      }\n\n      if (is.und(time)) {\n        time = performanceNow();\n      }\n\n      let dt = time - this.lastTime;\n\n      if (dt > 0) {\n        // http://gafferongames.com/game-physics/fix-your-timestep/\n        if (dt > 64) dt = 64;\n        this.updating = true;\n        const springs = this.springs;\n        if (springs.length) [...springs].forEach(spring => {\n          spring.idle || this.advance(dt, spring);\n        }); // Notify frame listeners.\n\n        const queues = this._queues;\n        const queue = queues[0];\n\n        if (queue.size) {\n          // Run and clear the queue.\n          queue.forEach(onFrame => onFrame());\n          queue.clear(); // Swap the queues.\n\n          queues[0] = queues[1];\n          queues[1] = queue;\n        }\n\n        const writes = this._writes;\n\n        if (writes.size) {\n          this.writing = true;\n          writes.forEach(write => write(time));\n          this.writing = false;\n          writes.clear();\n        }\n\n        this.updating = false;\n\n        if (!this.springs.length) {\n          return this.active = false;\n        }\n      }\n\n      this.lastTime = time;\n\n      this._requestFrame(this.update);\n\n      return true;\n    });\n  }\n  /**\r\n   * Schedule a function to run at the end of the current frame,\r\n   * after all springs have been updated.\r\n   *\r\n   * Pass `true` as the 2nd argument to run at the end of the **next** frame.\r\n   */\n\n\n  onFrame(cb, next) {\n    this._queues[next && this.updating ? 1 : 0].add(cb);\n\n    this._start();\n  }\n  /**\r\n   * Schedule a function run at the end of the current frame,\r\n   * after all `onFrame` callbacks have been called.\r\n   *\r\n   * Calling `onWrite` from inside an `onWrite` callback simply\r\n   * calls the nested write immediately.\r\n   */\n\n\n  onWrite(cb) {\n    if (this.writing) {\n      cb(this.lastTime);\n    } else {\n      this._writes.add(cb);\n    }\n  }\n  /**\r\n   * Start animating the given spring.\r\n   *\r\n   * Beware: Never `start` the same spring twice (without `stop` between).\r\n   */\n\n\n  start(spring) {\n    const springs = this.springs;\n    let i = springs.findIndex(s => s.priority > spring.priority);\n    if (i < 0) i = springs.length;\n    springs.splice(i, 0, spring);\n\n    this._start();\n  }\n\n  _start() {\n    if (!this.active) {\n      this.active = true;\n      this.lastTime = performanceNow();\n\n      this._requestFrame(this.update);\n    }\n  }\n  /**\r\n   * Stop animating the given spring\r\n   */\n\n\n  stop(spring) {\n    const springs = this.springs;\n    const i = springs.indexOf(spring);\n    if (~i) springs.splice(i, 1);\n    return this;\n  }\n  /**\r\n   * Advance an animation forward one frame.\r\n   */\n\n\n  advance(dt, spring) {\n    let idle = true;\n    let changed = false;\n    const anim = spring.animation;\n    const parent = isFluidValue(anim.to) && anim.to;\n    const payload = isAnimationValue(parent) && parent.node.getPayload();\n    anim.values.forEach((node, i) => {\n      if (node.done) return;\n      let to = payload ? payload[i].lastPosition : parent ? toArray(parent.get())[i] : anim.toValues[i]; // Parent springs must finish before their children can.\n\n      const canFinish = !payload || payload[i].done; // Jump to end value for immediate animations.\n\n      if (anim.immediate) {\n        node.done = canFinish;\n\n        if (node.setValue(to)) {\n          changed = true;\n        }\n\n        return;\n      }\n\n      const config = anim.config; // Loose springs never move.\n\n      if (config.tension == 0) {\n        node.done = true;\n        return;\n      }\n\n      const elapsed = node.elapsedTime += dt;\n      const from = anim.fromValues[i];\n      const v0 = node.v0 != null ? node.v0 : node.v0 = is.arr(config.velocity) ? config.velocity[i] : config.velocity;\n      let position = node.lastPosition;\n      let velocity;\n      let finished; // Duration easing\n\n      if (!is.und(config.duration)) {\n        let p = config.progress;\n        if (config.duration <= 0) p = 1;else p += (1 - p) * Math.min(1, elapsed / config.duration);\n        position = from + config.easing(p) * (to - from);\n        velocity = (position - node.lastPosition) / dt;\n        finished = p == 1;\n      } // Decay easing\n      else if (config.decay) {\n          const decay = config.decay === true ? 0.998 : config.decay;\n          const e = Math.exp(-(1 - decay) * elapsed);\n          position = from + v0 / (1 - decay) * (1 - e); // derivative of position\n\n          velocity = v0 * e;\n          finished = Math.abs(node.lastPosition - position) < 0.1;\n          if (finished) to = position;\n        } // Spring easing\n        else {\n            velocity = node.lastVelocity == null ? v0 : node.lastVelocity;\n            /** The smallest distance from a value before being treated like said value. */\n\n            const precision = config.precision || (from == to ? 0.005 : Math.min(1, Math.abs(to - from) * 0.001));\n            /** The velocity at which movement is essentially none */\n\n            const restVelocity = config.restVelocity || precision; // Bouncing is opt-in (not to be confused with overshooting)\n\n            const bounceFactor = config.clamp ? 0 : config.bounce;\n            const canBounce = !is.und(bounceFactor);\n            /** When `true`, the value is increasing over time */\n\n            const isGrowing = from == to ? node.v0 > 0 : from < to;\n            /** When `true`, the velocity is considered moving */\n\n            let isMoving;\n            /** When `true`, the velocity is being deflected or clamped */\n\n            let isBouncing = false;\n            const step = 0.05 / config.w0;\n            const numSteps = Math.ceil(dt / step);\n\n            for (let n = 0; n < numSteps; ++n) {\n              isMoving = Math.abs(velocity) > restVelocity;\n\n              if (!isMoving) {\n                finished = Math.abs(to - position) <= precision;\n\n                if (finished) {\n                  break;\n                }\n              }\n\n              if (canBounce) {\n                isBouncing = position == to || position > to == isGrowing; // Invert the velocity with a magnitude, or clamp it.\n\n                if (isBouncing) {\n                  velocity = -velocity * bounceFactor;\n                  position = to;\n                }\n              }\n\n              const springForce = -config.tension * 0.000001 * (position - to);\n              const dampingForce = -config.friction * 0.001 * velocity;\n              const acceleration = (springForce + dampingForce) / config.mass; // pt/ms^2\n\n              velocity = velocity + acceleration * step; // pt/ms\n\n              position = position + velocity * step;\n            }\n          }\n\n      if (Number.isNaN(position)) {\n        throw Error(`Found NaN value while advancing \"${spring.key}\" animation`);\n      }\n\n      if (finished && canFinish) {\n        node.done = true;\n      } else {\n        idle = false;\n      }\n\n      node.lastVelocity = velocity;\n\n      if (node.setValue(position, config.round)) {\n        changed = true;\n      }\n    });\n    spring.onFrame(idle, changed);\n  }\n\n}\n\nGlobals.assign({\n  frameLoop: new FrameLoop(),\n  createStringInterpolator: createStringInterpolator$1,\n  applyAnimatedValues: () => false\n});\n/** Advance all animations forward one frame */\n\nconst update = () => Globals.frameLoop.update();\n\nexport { Controller, FrameLoop, Spring, SpringValue, Trail, Transition, config, interpolate, to, update, useChain, useSpring, useSprings, useTrail, useTransition };","map":{"version":3,"sources":["src/useChain.js","src/helpers.ts","src/runAsync.ts","src/constants.ts","src/SpringValue.ts","src/Controller.ts","src/useSprings.ts","src/useSpring.ts","src/useTrail.ts","src/useTransition.tsx","src/legacy.js","src/interpolate.ts","src/FrameLoop.ts","src/globals.ts"],"names":["timeFrame","useIsomorphicLayoutEffect","prevDelay","each","ref","controllers","delay","timeSteps","isNaN","ctrl","props","p","Promise","start","updates","q","useMemo","useMemoOne","deps","callProp","value","args","is","matchProp","key","toArray","getProps","DEFAULT_PROPS","RESERVED_PROPS","children","config","from","to","reset","cancel","reverse","immediate","default","lazy","items","trail","sort","expires","initial","enter","leave","update","onAnimate","onStart","onRest","onChange","onFrame","forward","interpolateTo","getForwardProps","out","state","getValue","cancelled","asyncId","cancelToken","Symbol","isCancelled","defaultProps","prop","animate","arg1","parentTo","getPaused","resolve","result","finished","err","scheduleProps","action","setTimeout","run","reject","tension","friction","gentle","wobbly","stiff","slow","molasses","DISPOSED","CREATED","IDLE","PAUSED","ACTIVE","noop","BASE_CONFIG","configs","mass","velocity","progress","easing","t","clamp","SpringValue","AnimationValue","constructor","set","pause","checkDisposed","G","finish","anim","queue","spring","stop","dispose","onParentChange","node","setNodeWithValue","computeGoal","setNodeWithProps","range","_getNodeType","parent","isAnimationValue","parentType","isFluidValue","needsInterpolation","_getRange","_animate","timestamp","runAsync","_update","get","timestamps","diff","prevTo","prevFrom","changed","isEqual","started","lastVelocity","canMergeConfigs","Object","damping","Math","nodeType","Error","goal","onRestQueue","i","_to","_set","_onChange","idle","_onPriorityChange","_reset","_start","child","_stop","name","src","dest","output","nextId","lastAsyncId","Controller","s","promises","keys","asyncTo","results","_get","values","_setSprings","extractKeys","_onFrame","getDefinedKeys","obj","Array","useSprings","length","propsFn","arguments","ctrls","prevLength","usePrev","api","useImperativeHandle","useOnce","useSpring","isFn","useTrail","propsArg","springs","MOUNT","ENTER","UPDATE","LEAVE","useTransition","data","Infinity","transitions","getKeys","usedTransitions","useRef","prevTransitions","clearTimeout","reused","phase","item","a","b","forceUpdate","useForceUpdate","changes","isLeave","payload","now","change","render","elem","id","trails","interpolate","deprecateInterpolate","FrameLoop","requestFrame","fn","time","dt","queues","writes","write","next","onWrite","cb","advance","canFinish","elapsed","v0","position","decay","e","precision","restVelocity","bounceFactor","canBounce","isGrowing","isBouncing","step","numSteps","n","isMoving","springForce","dampingForce","acceleration","Number","Globals","frameLoop","applyAnimatedValues"],"mappings":"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","sourcesContent":["import { useIsomorphicLayoutEffect, each, is, toArray, isFluidValue, needsInterpolation, isEqual, usePrev, useOnce, useForceUpdate, Globals } from '@react-spring/shared';\nexport { Globals, createInterpolator, isFluidValue, makeFluidValue } from '@react-spring/shared';\nimport React, { useMemo as useMemo$1, useImperativeHandle, useRef } from 'react';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { frameLoop, createStringInterpolator, now, skipAnimation, requestAnimationFrame, performanceNow } from '@react-spring/shared/globals';\nimport { useMemoOne } from 'use-memo-one';\nimport { AnimationValue, isAnimationValue, AnimatedString, AnimatedValue, AnimatedArray, Into } from '@react-spring/animated';\nexport { AnimationValue, Into, isAnimationValue } from '@react-spring/animated';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport { deprecateInterpolate } from '@react-spring/shared/deprecations';\nimport { createStringInterpolator as createStringInterpolator$1 } from '@react-spring/shared/stringInterpolation';\n\n/** API\n *  useChain(references, timeSteps, timeFrame)\n */\n\nfunction useChain(refs, timeSteps, timeFrame) {\n  if (timeFrame === void 0) {\n    timeFrame = 1000;\n  }\n\n  useIsomorphicLayoutEffect(() => {\n    if (timeSteps) {\n      let prevDelay = 0;\n      each(refs, (ref, i) => {\n        if (!ref.current) return;\n        const controllers = ref.current.controllers;\n\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i]; // Use the previous delay if none exists.\n\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n          each(controllers, ctrl => {\n            each(ctrl.queue, props => {\n              props.delay = delay + (props.delay || 0);\n            });\n            ctrl.start();\n          });\n        }\n      });\n    } else {\n      let p = Promise.resolve();\n      each(refs, ref => {\n        const _ref = ref.current || {},\n              controllers = _ref.controllers,\n              start = _ref.start;\n\n        if (controllers && controllers.length) {\n          // Take the queue of each controller\n          const updates = controllers.map(ctrl => {\n            const q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          }); // Apply the queue when the previous ref stops animating\n\n          p = p.then(() => {\n            each(controllers, (ctrl, i) => ctrl.queue.push(...updates[i]));\n            return start();\n          });\n        }\n      });\n    }\n  });\n}\n\nconst useMemo = (create, deps) => useMemoOne(create, deps || [{}]);\nfunction callProp(value) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return is.fun(value) ? value(...args) : value;\n}\n/** Try to coerce the given value into a boolean using the given key */\n\nconst matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));\nconst getProps = (props, i, arg) => is.fun(props) ? props(i, arg) : is.arr(props) ? props[i] : _extends({}, props);\n/** These props can have default values */\n\nconst DEFAULT_PROPS = ['config', 'immediate', 'onAnimate', 'onStart', 'onChange', 'onRest'];\nconst RESERVED_PROPS = {\n  children: 1,\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  reset: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  lazy: 1,\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  leave: 1,\n  update: 1,\n  onAnimate: 1,\n  onStart: 1,\n  onRest: 1,\n  onChange: 1,\n  onFrame: 1\n};\n/**\r\n * Extract any properties whose keys are *not* reserved for customizing your\r\n * animations. All hooks use this function, which means `useTransition` props\r\n * are reserved for `useSpring` calls, etc.\r\n */\n\nfunction getForwardProps(props) {\n  const forward = {};\n  each(props, (value, prop) => {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n    }\n  });\n  return forward;\n}\n\nfunction interpolateTo(props) {\n  const to = getForwardProps(props);\n  const out = {\n    to\n  };\n  each(props, (val, key) => key in to || (out[key] = val));\n  return out;\n}\n\n/**\r\n * Start an async chain or an async script.\r\n *\r\n * You should always wrap `runAsync` calls with `scheduleProps` so that\r\n * you have access to `RunAsyncProps` instead of the usual `SpringProps`.\r\n *\r\n * The `T` parameter can be a set of animated values (as an object type)\r\n * or a primitive type for a single animated value.\r\n */\n\nasync function runAsync(to, props, state, getValue, getPaused, update, stop) {\n  if (props.cancel) {\n    state.asyncTo = undefined;\n    return {\n      value: getValue(),\n      cancelled: true\n    };\n  } // Wait for the previous async animation to be cancelled.\n  else if (props.reset) {\n      await state.promise;\n    } // Async animations are only replaced when \"props.to\" changes\n    // or when \"props.reset\" equals true.\n    else if (to === state.asyncTo) {\n        return state.promise;\n      }\n\n  state.asyncTo = to;\n  return state.promise = (async () => {\n    const asyncId = props.asyncId;\n    const cancelToken = Symbol.for('cancel');\n\n    const isCancelled = () => to !== state.asyncTo || asyncId <= (state.cancelId || 0);\n\n    const defaultProps = {};\n    each(DEFAULT_PROPS, prop => {\n      if (prop == 'onRest') return;\n\n      if (/function|object/.test(typeof props[prop])) {\n        defaultProps[prop] = props[prop];\n      }\n    });\n\n    const animate = (arg1, arg2) => {\n      if (isCancelled()) {\n        throw cancelToken;\n      }\n\n      const props = is.obj(arg1) ? _extends({}, arg1) : _extends({}, arg2, {\n        to: arg1\n      });\n      each(defaultProps, (value, prop) => {\n        if (is.und(props[prop])) {\n          props[prop] = value;\n        }\n      });\n      const parentTo = state.asyncTo;\n      return update(props).then(async result => {\n        if (state.asyncTo == null) {\n          state.asyncTo = parentTo;\n        }\n\n        if (isCancelled()) {\n          throw cancelToken;\n        }\n\n        if (getPaused()) {\n          await new Promise(resolve => {\n            state.unpause = resolve;\n          });\n          state.unpause = undefined;\n        }\n\n        return result;\n      });\n    };\n\n    let result;\n\n    try {\n      // Async sequence\n      if (is.arr(to)) {\n        for (const props of to) {\n          await animate(props);\n        }\n      } // Async script\n      else if (is.fun(to)) {\n          await to(animate, stop);\n        }\n\n      result = {\n        value: getValue(),\n        finished: true\n      };\n    } catch (err) {\n      if (err !== cancelToken) {\n        throw err;\n      }\n\n      result = {\n        value: getValue(),\n        cancelled: true\n      };\n    } finally {\n      state.promise = undefined;\n\n      if (to == state.asyncTo) {\n        state.asyncTo = undefined;\n      }\n    }\n\n    if (props.onRest) {\n      props.onRest(result);\n    }\n\n    return result;\n  })();\n} //\n// scheduleProps(props, state, action)\n//\n\n/**\r\n * Pass props to your action when any delay is finished and the\r\n * props weren't cancelled before then.\r\n */\n\nfunction scheduleProps(asyncId, props, state, action) {\n  return new Promise((resolve, reject) => {\n    let delay = props.delay,\n        cancel = props.cancel,\n        reset = props.reset;\n\n    if (is.num(delay) && delay > 0) {\n      setTimeout(run, delay);\n    } else run();\n\n    function run() {\n      // Might be cancelled during delay.\n      if (asyncId <= (state.cancelId || 0)) {\n        cancel = true;\n      } else {\n        cancel = matchProp(cancel, state.key);\n\n        if (cancel) {\n          state.cancelId = asyncId;\n        }\n      }\n\n      reset = !cancel && matchProp(reset, state.key);\n\n      try {\n        action(_extends({}, props, {\n          asyncId,\n          cancel,\n          reset\n        }), resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n}\n\n// The `mass` prop defaults to 1\nconst config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n\n/** The spring cannot be animated */\n\nconst DISPOSED = 'DISPOSED';\n/** The spring has not animated yet */\n\nconst CREATED = 'CREATED';\n/** The spring has animated before */\n\nconst IDLE = 'IDLE';\n/** The spring is frozen in time */\n\nconst PAUSED = 'PAUSED';\n/** The spring is animating */\n\nconst ACTIVE = 'ACTIVE';\n\nconst noop = () => {};\n\nconst BASE_CONFIG = _extends({}, config.default, {\n  mass: 1,\n  velocity: 0,\n  progress: 0,\n  easing: t => t,\n  clamp: false\n});\n/** An opaque animatable value */\n\n\nclass SpringValue extends AnimationValue {\n  constructor(key) {\n    super(key);\n    /** The animation state */\n\n    this.animation = {\n      value: this\n    };\n    /** The lifecycle phase of this spring */\n\n    this._phase = CREATED;\n    /** The last time each prop changed */\n\n    this._timestamps = {};\n    /** Some props have customizable default values */\n\n    this._defaultProps = {};\n    /** Cancel any update from before this timestamp */\n\n    this._lastAsyncId = 0;\n    this._state = {\n      key\n    };\n  }\n\n  get idle() {\n    return !this.is(ACTIVE);\n  }\n  /** Check the current phase */\n\n\n  is(phase) {\n    return this._phase == phase;\n  }\n  /** Set the current value, while stopping the current animation */\n\n\n  set(value) {\n    if (this._set(value) && this.idle) {\n      // Since \"_stop\" calls \"_onChange\" only when not idle, we need this.\n      this._onChange(this.get(), true);\n    }\n\n    this._stop();\n\n    return this;\n  }\n  /**\r\n   * Freeze the active animation in time.\r\n   * This does nothing when not animating.\r\n   *\r\n   * Call `start` to unpause.\r\n   */\n\n\n  pause() {\n    checkDisposed(this, 'pause');\n\n    if (!this.idle) {\n      this._phase = PAUSED;\n      frameLoop.stop(this);\n    }\n  }\n  /**\r\n   * Skip to the end of the current animation.\r\n   *\r\n   * All `onRest` callbacks are passed `{finished: true}`\r\n   */\n\n\n  finish(to) {\n    if (!this.idle) {\n      const anim = this.animation; // Decay animations have an implicit goal.\n\n      if (!anim.config.decay && is.und(to)) {\n        to = anim.to;\n      } // Set the value if we can.\n\n\n      if (!is.und(to)) {\n        this._set(to);\n      } // Exit the frameloop.\n\n\n      this._stop(true);\n    }\n\n    return this;\n  }\n  /** Push props into the pending queue. */\n\n\n  update(props) {\n    checkDisposed(this, 'update'); // Ensure the initial value can be accessed by animated components.\n\n    this.setNodeWithProps(props);\n    const queue = this.queue || (this.queue = []);\n    queue.push(props);\n    return this;\n  }\n\n  async start(to, arg2) {\n    checkDisposed(this, 'start'); // Unpause if possible.\n\n    if (this.is(PAUSED)) {\n      this._start();\n\n      if (this._state.asyncTo) {\n        this._state.unpause();\n      }\n    }\n\n    let queue;\n\n    if (!is.und(to)) {\n      queue = [is.obj(to) ? to : _extends({}, arg2, {\n        to\n      })];\n    } else {\n      queue = this.queue || [];\n      this.queue = [];\n    }\n\n    await Promise.all(queue.map(props => this._animate(props)));\n    return {\n      finished: true,\n      value: this.get(),\n      spring: this\n    };\n  }\n  /**\r\n   * Stop the current animation, and cancel any delayed updates.\r\n   */\n\n\n  stop() {\n    if (!this.is(DISPOSED)) {\n      this._state.cancelId = this._lastAsyncId;\n\n      this._to(this.get());\n\n      this._stop();\n    }\n\n    return this;\n  }\n  /** Restart the animation. */\n\n\n  reset() {\n    this._animate({\n      reset: true\n    });\n  }\n  /** Prevent future animations, and stop the current animation */\n\n\n  dispose() {\n    if (!this.is(DISPOSED)) {\n      if (this.animation) {\n        // Prevent \"onRest\" calls when disposed.\n        this.animation.onRest = undefined;\n      }\n\n      this.stop();\n      this._phase = DISPOSED;\n    }\n  }\n  /** Observe value changes. To stop observing, call the returned function. */\n\n\n  onChange(fn) {\n    this._children.add(fn);\n\n    return () => this._children.delete(fn);\n  }\n  /** @internal */\n\n\n  onParentChange(value, idle) {\n    const anim = this.animation; // The \"FrameLoop\" handles everything other than immediate animation.\n\n    if (anim.immediate) {\n      if (idle) {\n        this.finish(value);\n      } else {\n        this._set(value);\n      }\n    } // When our parent is not a spring, it won't tell us to enter the frameloop\n    // because it never does so itself. Instead, we must react to value changes.\n    else if (this.idle) {\n        anim.fromValues = anim.values.map(node => node.lastPosition);\n\n        this._start();\n      }\n  }\n  /** @internal Called by the frameloop */\n\n\n  onFrame(idle, changed) {\n    if (idle) {\n      this.finish();\n    } else if (changed) {\n      this._onChange(this.get());\n    }\n  }\n  /**\r\n   * @internal\r\n   * Analyze the given `value` to determine which data type is being animated.\r\n   * Then, create an `Animated` node for that data type and make it our `node`.\r\n   */\n\n\n  setNodeWithValue(value) {\n    if (value != null) {\n      this.node = this._getNodeType(value).create(computeGoal(value));\n    }\n  }\n  /**\r\n   * @internal\r\n   * Analyze the given `props` to determine which data type is being animated.\r\n   * Then, create an `Animated` node for that data type and make it our `node`.\r\n   * If we already have a `node`, do nothing but return the `{from, to}` range.\r\n   */\n\n\n  setNodeWithProps(props) {\n    const range = this._getRange(props);\n\n    if (!this.node) {\n      this.setNodeWithValue(range.from != null ? range.from : range.to);\n    }\n\n    return range;\n  }\n  /** Return the `Animated` node constructor for a given value */\n\n\n  _getNodeType(value) {\n    const parent = isAnimationValue(value) ? value : null;\n    const parentType = parent && parent.node && parent.node.constructor;\n\n    if (!parent && isFluidValue(value)) {\n      value = value.get();\n    }\n\n    return parentType == AnimatedString ? AnimatedValue : parentType || (is.arr(value) ? AnimatedArray : needsInterpolation(value) ? AnimatedString : AnimatedValue);\n  }\n  /** Pluck the `to` and `from` props */\n\n\n  _getRange(props) {\n    const to = props.to,\n          from = props.from;\n    const key = this.key || '';\n    return {\n      to: !is.obj(to) || isFluidValue(to) ? to : to[key],\n      from: !is.obj(from) || isFluidValue(from) ? from : from[key]\n    };\n  }\n  /** Update this value's animation using the given props. */\n\n\n  _animate(props) {\n    // Ensure the initial value can be accessed by animated components.\n    const range = this.setNodeWithProps(props);\n    const timestamp = now();\n    return scheduleProps(++this._lastAsyncId, props, this._state, (props, resolve) => {\n      const to = props.to;\n\n      if (is.arr(to) || is.fun(to)) {\n        resolve(runAsync(to, props, this._state, () => this.get(), () => this.is(PAUSED), this.start.bind(this), this.stop.bind(this)));\n      } else if (props.cancel) {\n        this.stop();\n        resolve({\n          value: this.get(),\n          cancelled: true\n        });\n      } else {\n        this._update(range, props, timestamp, resolve);\n      }\n    });\n  }\n  /** Update the internal `animation` object */\n\n\n  _update(_ref, props, timestamp, resolve) {\n    let to = _ref.to,\n        from = _ref.from;\n    const defaultProps = this._defaultProps;\n    /** Get the value of a prop, or its default value */\n\n    const get = prop => !is.und(props[prop]) ? props[prop] : defaultProps[prop];\n\n    const onAnimate = get('onAnimate');\n\n    if (onAnimate) {\n      onAnimate(props, this);\n    } // Cast from a partial type.\n\n\n    const anim = this.animation;\n    const timestamps = this._timestamps;\n    /** Return true if our prop can be used. This only affects delayed props. */\n\n    const diff = prop => {\n      if (timestamp >= (timestamps[prop] || 0)) {\n        timestamps[prop] = timestamp;\n        return true;\n      }\n\n      return false;\n    };\n\n    const prevTo = anim.to,\n          prevFrom = anim.from; // The \"reverse\" prop only affects one update.\n\n    if (props.reverse) {\n      var _ref2 = [from, to];\n      to = _ref2[0];\n      from = _ref2[1];\n    }\n\n    if (!is.und(to) && diff('to')) {\n      this._to(to);\n    } else {\n      to = prevTo;\n    }\n\n    if (!is.und(from) && diff('from')) {\n      anim.from = from;\n    } else {\n      from = anim.from;\n    }\n\n    if (isFluidValue(from)) {\n      from = from.get();\n    }\n\n    const reset = props.reset && !is.und(from);\n    const changed = !is.und(to) && !isEqual(to, prevTo);\n    const parent = isFluidValue(to) && to;\n    /** The current value */\n\n    let value = reset ? from : this.get();\n\n    if (is.und(from)) {\n      from = value;\n    }\n    /** When true, this spring must be in the frameloop. */\n\n\n    let started = !!parent || (changed || reset) && !isEqual(value, to);\n    /** The initial velocity before this `animate` call. */\n\n    const lastVelocity = anim.config ? anim.config.velocity : 0; // The \"config\" prop either overwrites or merges into the existing config.\n\n    let config = props.config;\n\n    if (config || started || !anim.config) {\n      const key = this.key || '';\n      config = _extends({}, callProp(defaultProps.config, key), callProp(config, key));\n\n      if (!started && canMergeConfigs(config, anim.config)) {\n        Object.assign(anim.config, config);\n      } else {\n        anim.config = config = _extends({}, BASE_CONFIG, config);\n      } // Derive \"tension\" and \"friction\" from \"frequency\" and \"damping\".\n\n\n      if (!is.und(config.frequency)) {\n        const damping = is.und(config.damping) ? 1 : config.damping;\n        config.tension = Math.pow(config.frequency, 2) * config.mass;\n        config.friction = damping * Math.sqrt(config.tension * config.mass) / 0.5;\n      } // Cache the angular frequency in rad/ms\n\n\n      config.w0 = Math.sqrt(config.tension / config.mass) / 1000;\n    } else {\n      config = anim.config;\n    } // Always start animations with velocity.\n\n\n    if (!started && (config.decay || !is.und(to))) {\n      started = !isEqual(config.velocity, lastVelocity);\n    } // Reset our internal `Animated` node if starting.\n\n\n    let node = this.node;\n    let nodeType;\n\n    if (changed) {\n      nodeType = this._getNodeType(to);\n\n      if (nodeType !== node.constructor) {\n        throw Error(`Cannot animate to the given \"to\" prop, because the current value has a different type`);\n      }\n    } else {\n      nodeType = node.constructor;\n    } // The final value of our animation, excluding the \"to\" value.\n    // The \"FrameLoop\" decides our goal value when \"parent\" exists.\n\n\n    let goal = parent ? null : computeGoal(to);\n\n    if (nodeType == AnimatedString) {\n      from = 0;\n      goal = 1;\n    } // Ensure the current value equals the \"from\" value when reset\n    // and when the \"from\" value is updated before the first animation.\n\n\n    if (reset || this.is(CREATED) && !is.und(anim.from) && !isEqual(anim.from, prevFrom)) {\n      node.setValue(value = from);\n    } // Event props are replaced on every update.\n\n\n    anim.onStart = get('onStart');\n    anim.onChange = get('onChange'); // Update the default props.\n\n    if (props.default) {\n      each(DEFAULT_PROPS, prop => {\n        // Default props can only be null, an object, or a function.\n        if (/function|object/.test(typeof props[prop])) {\n          defaultProps[prop] = props[prop];\n        }\n      });\n    }\n\n    if (!started) {\n      // Resolve the \"animate\" promise.\n      return resolve({\n        value,\n        spring: this,\n        finished: true\n      });\n    } // This must come *before* \"fromValues\" is set,\n    // because it updates \"node.lastPosition\"\n\n\n    this._reset();\n\n    anim.values = node.getPayload();\n    anim.toValues = parent ? null : toArray(goal);\n    anim.fromValues = anim.values.map(node => node.lastPosition);\n    anim.immediate = !(parent || is.num(goal) || is.arr(goal)) || !!matchProp(get('immediate'), this.key);\n    const onRestQueue = anim.onRest; // The \"onRest\" prop is always first in the queue.\n\n    anim.onRest = [get('onRest') || noop, resolve]; // Resolve the promise for unfinished animations.\n\n    if (onRestQueue && onRestQueue.length > 1) {\n      const result = {\n        value,\n        spring: this,\n        cancelled: true\n      }; // Skip the \"onRest\" prop, as the animation is still active.\n\n      for (let i = 1; i < onRestQueue.length; i++) {\n        onRestQueue[i](result);\n      }\n    }\n\n    this._start();\n  }\n  /** Update the `animation.to` value, which might be a `FluidValue` */\n\n\n  _to(value) {\n    const anim = this.animation;\n\n    if (isFluidValue(anim.to)) {\n      if (value == anim.to) return;\n      anim.to.removeChild(this);\n    }\n\n    anim.to = value;\n\n    if (isFluidValue(value)) {\n      value.addChild(this);\n      this.priority = (value.priority || 0) + 1;\n    } else {\n      this.priority = 0;\n    }\n  }\n  /** Set the current value and our `node` if necessary. The `_onChange` method is *not* called. */\n\n\n  _set(value) {\n    if (isFluidValue(value)) {\n      value = value.get();\n    }\n\n    const node = this.node;\n\n    if (node) {\n      if (isEqual(value, node.getValue())) {\n        return false;\n      }\n\n      node.setValue(value);\n    } else {\n      this.setNodeWithValue(value);\n    }\n\n    return true;\n  }\n  /** Notify change observers */\n\n\n  _onChange(value, idle) {\n    if (idle === void 0) {\n      idle = false;\n    }\n\n    const anim = this.animation;\n\n    if (!anim.changed && !idle) {\n      anim.changed = true; // The \"onStart\" prop is called on the first change after entering the\n      // frameloop, but never for immediate animations.\n\n      if (anim.onStart) {\n        anim.onStart(this);\n      }\n    }\n\n    if (anim.onChange) {\n      anim.onChange(value, this);\n    }\n\n    super._onChange(value, idle);\n  }\n\n  _onPriorityChange(priority) {\n    if (!this.idle) {\n      // Re-enter the frameloop so our new priority is used.\n      frameLoop.stop(this).start(this);\n    }\n\n    super._onPriorityChange(priority);\n  }\n  /** Reset our node, and the nodes of every descendant spring */\n\n\n  _reset(goal) {\n    if (goal === void 0) {\n      goal = computeGoal(this.animation.to);\n    }\n\n    super._reset(goal);\n  }\n  /** Enter the frameloop */\n\n\n  _start() {\n    if (this.idle) {\n      this._phase = ACTIVE; // Animations without \"onRest\" cannot enter the frameloop.\n\n      const anim = this.animation;\n\n      if (anim.onRest) {\n        anim.changed = false; // The \"skipAnimation\" global avoids the frameloop.\n\n        if (skipAnimation) {\n          this.finish(anim.to);\n        } else {\n          frameLoop.start(this);\n        }\n      } // Tell animatable children to enter the frameloop.\n\n\n      each(this._children, child => {\n        if (child instanceof SpringValue) {\n          child._start();\n        }\n      });\n    }\n  }\n  /** Exit the frameloop and notify `onRest` listeners */\n\n\n  _stop(finished) {\n    if (finished === void 0) {\n      finished = false;\n    }\n\n    if (!this.idle) {\n      this._phase = IDLE; // Always let change observers know when a spring becomes idle.\n\n      this._onChange(this.get(), true);\n\n      const anim = this.animation;\n      const onRestQueue = anim.onRest; // Animations without \"onRest\" never enter the frameloop.\n\n      if (onRestQueue) {\n        frameLoop.stop(this);\n        each(anim.values, node => {\n          node.done = true;\n        }); // Preserve the \"onRest\" prop between animations.\n\n        anim.onRest = [onRestQueue[0]]; // Never call the \"onRest\" prop for immediate or no-op animations.\n\n        if (anim.immediate || !anim.changed) {\n          onRestQueue[0] = noop;\n        }\n\n        const result = {\n          value: this.get(),\n          spring: this,\n          finished\n        };\n        each(onRestQueue, onRest => onRest(result));\n      }\n    }\n  }\n\n} // TODO: makes this tree-shakeable\n\nfunction checkDisposed(spring, name) {\n  if (spring.is(DISPOSED)) {\n    throw Error(`Cannot call \"${name}\" of disposed \"${spring.constructor.name}\" object`);\n  }\n} // Merge configs when the existence of \"decay\" or \"duration\" has not changed.\n\n\nfunction canMergeConfigs(src, dest) {\n  return !!dest && is.und(src.decay) == is.und(dest.decay) && is.und(src.duration) == is.und(dest.duration);\n} // Compute the goal value, converting \"red\" to \"rgba(255, 0, 0, 1)\" in the process\n\n\nfunction computeGoal(value) {\n  return is.arr(value) ? value.map(computeGoal) : isFluidValue(value) ? computeGoal(value.get()) : needsInterpolation(value) ? createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\n\nlet nextId = 1;\nlet lastAsyncId = 0;\nclass Controller {\n  constructor(props) {\n    this.id = nextId++;\n    /** The values that changed in the last animation frame */\n\n    this.frame = {};\n    /** Fallback values for undefined props */\n\n    this.defaultProps = {};\n    /** The queue of pending props */\n\n    this.queue = [];\n    /** The current controller-only props (eg: `onFrame` and async state) */\n\n    this._props = {};\n    /** The spring values that manage their animations */\n\n    this._springs = {};\n    this._onChange = this._onChange.bind(this);\n    this._onFrame = this._onFrame.bind(this);\n\n    if (props) {\n      props.default = true;\n      this.start(props);\n    }\n  }\n  /** Equals true when no springs are animating */\n\n\n  get idle() {\n    return !this._props.promise && Object.values(this._springs).every(s => s.idle);\n  }\n  /** Get all existing `SpringValue` objects. This clones the internal store. */\n\n\n  get springs() {\n    return _extends({}, this._springs);\n  }\n\n  get(key) {\n    return this._springs[key];\n  }\n  /** Push an update onto the queue of each value. */\n\n\n  update(props) {\n    if (props) this.queue.push(this._update(props));\n    return this;\n  }\n  /**\r\n   * Start the queued animations for every spring, and resolve the returned\r\n   * promise once all queued animations have finished or been cancelled.\r\n   *\r\n   * When you pass a queue (instead of nothing), that queue is used instead of\r\n   * the queued animations added with the `update` method, which are left alone.\r\n   */\n\n\n  async start(queue) {\n    if (queue) {\n      queue = toArray(queue).map(props => this._update(props));\n    } else {\n      queue = this.queue;\n      this.queue = [];\n    }\n\n    const promises = [];\n    each(queue, props => {\n      const to = props.to,\n            onFrame = props.onFrame,\n            keys = props.keys;\n      const asyncTo = (is.arr(to) || is.fun(to)) && to;\n\n      if (asyncTo) {\n        props.to = undefined;\n      }\n\n      promises.push( // Send updates to every affected key.\n      ...keys.map(key => this._springs[key].start(props)), // Schedule controller-only props.\n      scheduleProps(++lastAsyncId, props, this._props, (props, resolve) => {\n        if (!props.cancel) {\n          // Never reuse \"onFrame\" from a previous update.\n          this._props.onFrame = onFrame || this.defaultProps.onFrame;\n\n          if (onFrame && props.default) {\n            this.defaultProps.onFrame = onFrame;\n          }\n        } // Start, replace, or cancel the async animation.\n\n\n        if (asyncTo) {\n          resolve(runAsync(asyncTo, props, this._props, this._get.bind(this), () => false, // TODO: add pausing to Controller\n          this.start.bind(this), this.stop.bind(this)));\n        } else {\n          resolve({\n            value: 0,\n            finished: !props.cancel\n          });\n        }\n      }));\n    });\n    const results = await Promise.all(promises);\n    return {\n      value: this._get(),\n      finished: results.every(result => result.finished)\n    };\n  }\n  /** Stop one animation, some animations, or all animations */\n\n\n  stop(keys) {\n    if (is.und(keys)) {\n      each(this._springs, spring => spring.stop());\n    } else {\n      each(toArray(keys), key => this._springs[key].stop());\n    }\n\n    return this;\n  }\n  /** Restart every animation. */\n\n\n  reset() {\n    each(this._springs, spring => spring.reset()); // TODO: restart async \"to\" prop\n\n    return this;\n  }\n  /** Destroy every spring in this controller */\n\n\n  dispose() {\n    this._props.asyncTo = undefined;\n    each(this._springs, spring => spring.dispose());\n    this._springs = {};\n  }\n  /** Get the current value of every spring */\n\n\n  _get() {\n    const values = {};\n    each(this._springs, (spring, key) => {\n      values[key] = spring.get();\n    });\n    return values;\n  }\n  /** Create a spring for every given key, and ensure they have `Animated` nodes. */\n\n\n  _setSprings(keys, from, to) {\n    each(keys, key => {\n      if (!this._springs[key]) {\n        const spring = this._springs[key] = new SpringValue(key);\n        spring.addChild(this._onChange);\n        spring.setNodeWithProps({\n          from,\n          to\n        });\n      }\n    });\n  }\n  /** Prepare an update with the given props. */\n\n\n  _update(propsArg) {\n    const props = interpolateTo(propsArg);\n    const keys = props.keys = extractKeys(props, this._springs);\n    let from = props.from,\n        to = props.to; // Avoid sending async \"to\" prop to springs.\n\n    if (is.arr(to) || is.fun(to)) {\n      to = undefined;\n    } // Create our springs and give them values.\n\n\n    if (from || to) {\n      this._setSprings(keys, from, to);\n    }\n\n    return props;\n  }\n  /** @internal Attached as an observer to every spring */\n\n\n  _onChange(value, spring) {\n    if (this._props.onFrame) {\n      this.frame[spring.key] = value;\n      frameLoop.onFrame(this._onFrame);\n    }\n  }\n  /** @internal Called at the end of every animation frame */\n\n\n  _onFrame() {\n    if (Object.keys(this.frame).length) {\n      this._props.onFrame(this.frame);\n\n      this.frame = {};\n    }\n  }\n\n}\n/** Determine which keys should receive an update */\n\nfunction extractKeys(props, springs) {\n  const keys = new Set();\n  /** Collect keys with a defined value */\n\n  const getDefinedKeys = obj => each(obj, (value, key) => {\n    if (!is.und(value)) {\n      keys.add(key);\n    }\n  });\n\n  const from = props.from,\n        to = props.to;\n  if (is.obj(to)) getDefinedKeys(to);\n  if (from) getDefinedKeys(from); // When neither \"from\" or \"to\" have a key with a defined value,\n  // return the keys for every existing spring.\n\n  return keys.size ? Array.from(keys) : Object.keys(springs);\n}\n\n/** @internal */\n\nfunction useSprings(length, props, deps) {\n  const propsFn = is.fun(props) && props;\n\n  if (propsFn && arguments.length < 3) {\n    deps = []; // Skip updates after first render.\n  } // The \"ref\" prop is taken from the props of the first spring only.\n  // The ref is assumed to *never* change after the first render.\n\n\n  let ref;\n  const ctrls = useMemo(() => [], []);\n  const updates = [];\n  const prevLength = usePrev(length) || 0;\n  useMemo(() => {\n    if (prevLength > length) {\n      for (let i = length; i < prevLength; i++) {\n        ctrls[i].dispose();\n      }\n    }\n\n    ctrls.length = length;\n\n    for (let i = 0; i < length; i++) {\n      const ctrl = ctrls[i] || (ctrls[i] = new Controller());\n      const update = propsFn ? propsFn(i, ctrl) : props[i];\n\n      if (update) {\n        update.default = true;\n\n        if (i == 0 && update.ref) {\n          ref = update.ref;\n        }\n\n        if (i < prevLength) {\n          updates[i] = update;\n        } else {\n          // Update new controllers immediately, so their\n          // spring values exist during first render.\n          ctrl.update(update);\n        }\n      }\n    }\n  }, deps);\n  const api = useMemo$1(() => ({\n    get controllers() {\n      return ctrls;\n    },\n\n    update: props => {\n      each(ctrls, (ctrl, i) => {\n        ctrl.update(getProps(props, i, ctrl));\n        if (!ref) ctrl.start();\n      });\n      return api;\n    },\n\n    async start() {\n      const results = await Promise.all(ctrls.map(ctrl => ctrl.start()));\n      return {\n        value: results.map(result => result.value),\n        finished: results.every(result => result.finished)\n      };\n    },\n\n    stop: keys => each(ctrls, ctrl => ctrl.stop(keys))\n  }), []);\n  useImperativeHandle(ref, () => api);\n  useIsomorphicLayoutEffect(() => {\n    each(updates, (update, i) => ctrls[i].update(update));\n\n    if (!ref) {\n      each(ctrls, ctrl => ctrl.start());\n    }\n  }, deps);\n  useOnce(() => () => {\n    each(ctrls, ctrl => ctrl.dispose());\n  });\n  const values = ctrls.map(ctrl => ctrl.springs);\n  return propsFn || arguments.length == 3 ? [values, api.update, api.stop] : values;\n}\n\n/** @internal */\n\nfunction useSpring(props, deps) {\n  const isFn = is.fun(props);\n\n  const _useSprings = useSprings(1, isFn ? props : [props], deps),\n        _useSprings$ = _useSprings[0],\n        values = _useSprings$[0],\n        update = _useSprings[1],\n        stop = _useSprings[2];\n\n  return isFn || arguments.length == 3 ? [values, update, stop] : values;\n}\n\nfunction useTrail(length, propsArg, deps) {\n  const propsFn = is.fun(propsArg) && propsArg;\n\n  if (propsFn && arguments.length < 3) {\n    deps = []; // Skip updates after first render.\n  }\n\n  const ctrls = [];\n  const result = useSprings(length, (i, ctrl) => {\n    ctrls[i] = ctrl;\n    return getProps(propsArg, i, ctrl);\n  }, deps);\n  useIsomorphicLayoutEffect(() => {\n    const reverse = is.obj(propsArg) && propsArg.reverse;\n\n    for (let i = 0; i < ctrls.length; i++) {\n      const parent = ctrls[i + (reverse ? 1 : -1)];\n      if (parent) ctrls[i].update({\n        to: parent.springs\n      }).start();\n    }\n  }, deps);\n  const update = result[1];\n\n  result[1] = propsArg => {\n    const reverse = is.obj(propsArg) && propsArg.reverse;\n    return update((i, ctrl) => {\n      const props = getProps(propsArg, i, ctrl);\n      const parent = ctrls[i + (reverse ? 1 : -1)];\n      if (parent) props.to = parent.springs;\n      return props;\n    });\n  };\n\n  return propsFn ? result : result[0];\n}\n\n/** This transition is being mounted */\n\nconst MOUNT = 0;\n/** This transition is entering or has entered */\n\nconst ENTER = 1;\n/** This transition had its animations updated */\n\nconst UPDATE = 2;\n/** This transition will expire after animating */\n\nconst LEAVE = 3;\n\nfunction getKeys(items, _ref) {\n  let key = _ref.key,\n      _ref$keys = _ref.keys,\n      keys = _ref$keys === void 0 ? key : _ref$keys;\n  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);\n}\n\nfunction useTransition(data, props, deps) {\n  const ref = props.ref,\n        reset = props.reset,\n        sort = props.sort,\n        _props$trail = props.trail,\n        trail = _props$trail === void 0 ? 0 : _props$trail,\n        _props$expires = props.expires,\n        expires = _props$expires === void 0 ? Infinity : _props$expires; // Every item has its own transition.\n\n  const items = toArray(data);\n  const transitions = []; // Keys help with reusing transitions between renders.\n  // The `key` prop can be undefined (which means the items themselves are used\n  // as keys), or a function (which maps each item to its key), or an array of\n  // keys (which are assigned to each item by index).\n\n  const keys = getKeys(items, props); // The \"onRest\" callbacks need a ref to the latest transitions.\n\n  const usedTransitions = useRef(null);\n  const prevTransitions = usedTransitions.current;\n  useIsomorphicLayoutEffect(() => {\n    usedTransitions.current = transitions;\n  }); // Destroy all transitions on dismount.\n\n  useOnce(() => () => each(usedTransitions.current, t => {\n    if (t.expiresBy != null) {\n      clearTimeout(t.expirationId);\n    }\n\n    t.ctrl.dispose();\n  })); // Map old indices to new indices.\n\n  const reused = [];\n  if (prevTransitions && !reset) each(prevTransitions, (t, i) => {\n    // Expired transitions are not rendered.\n    if (t.expiresBy != null) {\n      clearTimeout(t.expirationId);\n    } else {\n      i = reused[i] = keys.indexOf(t.key);\n      if (~i) transitions[i] = t;\n    }\n  }); // Mount new items with fresh transitions.\n\n  each(items, (item, i) => {\n    transitions[i] || (transitions[i] = {\n      key: keys[i],\n      item,\n      phase: MOUNT,\n      ctrl: new Controller()\n    });\n  }); // Update the item of any transition whose key still exists,\n  // and ensure leaving transitions are rendered until they finish.\n\n  if (reused.length) {\n    let i = -1;\n    each(reused, (keyIndex, prevIndex) => {\n      const t = prevTransitions[prevIndex];\n\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = _extends({}, t, {\n          item: items[keyIndex]\n        });\n      } else if (props.leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n\n  if (is.fun(sort)) {\n    transitions.sort((a, b) => sort(a.item, b.item));\n  } // Track cumulative delay for the \"trail\" prop.\n\n\n  let delay = -trail; // Expired transitions use this to dismount.\n\n  const forceUpdate = useForceUpdate();\n  const defaultProps = {};\n  each(DEFAULT_PROPS, prop => {\n    if (/function|object/.test(typeof props[prop])) {\n      defaultProps[prop] = props[prop];\n    }\n  }); // Generate changes to apply in useEffect.\n\n  const changes = new Map();\n  each(transitions, (t, i) => {\n    let to;\n    let from;\n    let phase;\n\n    if (t.phase == MOUNT) {\n      to = props.enter;\n      phase = ENTER; // The \"initial\" prop is only used on first render. It always overrides\n      // the \"from\" prop when defined, and it makes \"enter\" instant when null.\n\n      from = props.initial;\n\n      if (is.und(from) || prevTransitions && !reset) {\n        from = props.from;\n      }\n    } else {\n      const isLeave = keys.indexOf(t.key) < 0;\n\n      if (t.phase < LEAVE) {\n        if (isLeave) {\n          to = props.leave;\n          phase = LEAVE;\n        } else if (to = props.update) {\n          phase = UPDATE;\n        } else return;\n      } else if (!isLeave) {\n        to = props.enter;\n        phase = ENTER;\n      } else return;\n    } // The payload is used to update the spring props once the current render is committed.\n\n\n    const payload = _extends({}, defaultProps, {\n      // When \"to\" is a function, it can return (1) an array of \"useSpring\" props,\n      // (2) an async function, or (3) an object with any \"useSpring\" props.\n      to: to = callProp(to, t.item, i),\n      from: callProp(from, t.item, i),\n      delay: delay += trail,\n      config: callProp(props.config || defaultProps.config, t.item, i)\n    }, is.obj(to) && interpolateTo(to));\n\n    const onRest = payload.onRest;\n\n    payload.onRest = result => {\n      if (is.fun(onRest)) {\n        onRest(result);\n      }\n\n      if (t.phase == LEAVE && t.ctrl.idle) {\n        t.expiresBy = now() + expires;\n\n        if (expires <= 0) {\n          forceUpdate();\n        } else {\n          // Postpone dismounts while other controllers are active.\n          const transitions = usedTransitions.current;\n\n          if (transitions.every(t => t.ctrl.idle)) {\n            forceUpdate();\n          } // When `expires` is infinite, postpone dismount until next render.\n          else if (expires < Infinity) {\n              t.expirationId = setTimeout(forceUpdate, expires);\n            }\n        }\n      }\n    };\n\n    const change = {\n      phase\n    };\n    changes.set(t, change); // To ensure all Animated nodes exist during render,\n    // the payload must be applied immediately for new items.\n\n    if (t.phase > MOUNT) {\n      change.payload = payload;\n    } else {\n      t.ctrl.update(payload);\n    }\n  });\n  const api = useMemo$1(() => ({\n    get controllers() {\n      return usedTransitions.current.map(t => t.ctrl);\n    },\n\n    update(props) {\n      each(usedTransitions.current, (t, i) => t.ctrl.update(is.fun(props) ? props(i, t.ctrl) : is.arr(props) ? props[i] : props));\n      return api;\n    },\n\n    async start() {\n      const transitions = usedTransitions.current;\n      const results = await Promise.all(transitions.map(t => t.ctrl.start()));\n      return {\n        value: results.map(result => result.value),\n        finished: results.every(result => result.finished)\n      };\n    },\n\n    stop: keys => each(usedTransitions.current, t => t.ctrl.stop(keys))\n  }), []);\n  useImperativeHandle(ref, () => api);\n  useIsomorphicLayoutEffect(() => {\n    each(changes, (_ref2, t) => {\n      let phase = _ref2.phase,\n          payload = _ref2.payload;\n      t.phase = phase;\n      if (payload) t.ctrl.update(payload);\n      if (!ref) t.ctrl.start();\n    });\n  }, reset ? void 0 : deps);\n  return render => transitions.map(t => {\n    const elem = render(t.ctrl.springs, t.item, t);\n    return elem && elem.type ? React.createElement(elem.type, Object.assign({}, elem.props, {\n      key: is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id,\n      ref: elem.ref\n    })) : elem;\n  });\n}\n\nfunction Spring(_ref) {\n  let children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  return children(useSpring(props));\n}\nfunction Trail(_ref2) {\n  let items = _ref2.items,\n      children = _ref2.children,\n      props = _objectWithoutPropertiesLoose(_ref2, [\"items\", \"children\"]);\n\n  const trails = useTrail(items.length, props);\n  return items.map((item, index) => {\n    const result = children(item, index);\n    return is.fun(result) ? result(trails[index]) : result;\n  });\n}\nfunction Transition(_ref3) {\n  let items = _ref3.items,\n      children = _ref3.children,\n      props = _objectWithoutPropertiesLoose(_ref3, [\"items\", \"children\"]);\n\n  return useTransition(items, props)(children);\n}\n\n/** Map the value of one or more dependencies */\n\nconst to = function to(source) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return new Into(source, args);\n};\n/** @deprecated Use the `to` export instead */\n\nconst interpolate = function interpolate(source) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  return deprecateInterpolate(), new Into(source, args);\n};\n\nclass FrameLoop {\n  constructor(_temp) {\n    let _ref = _temp === void 0 ? {} : _temp,\n        update = _ref.update,\n        requestFrame = _ref.requestFrame;\n\n    /**\r\n     * The animated springs\r\n     */\n    this.springs = [];\n    /**\r\n     * True when at least one spring is animating.\r\n     */\n\n    this.active = false;\n    /** Equals true when a frame is being processed. */\n\n    this.updating = false;\n    /** Equals true when writing to native attributes. */\n\n    this.writing = false; // These queues are swapped at the end of every frame,\n    // after the current queue is drained.\n\n    this._queues = [new Set(), new Set()];\n    /** `onWrite` callbacks are flushed on every frame, after `onFrame` callbacks are flushed. */\n\n    this._writes = new Set();\n\n    this._requestFrame = // The global `requestAnimationFrame` must be dereferenced to avoid \"Illegal invocation\" errors\n    requestFrame || (fn => (0, requestAnimationFrame)(fn));\n\n    this.update = update && update.bind(this) || (time => {\n      if (!this.active) {\n        return false;\n      }\n\n      if (is.und(time)) {\n        time = performanceNow();\n      }\n\n      let dt = time - this.lastTime;\n\n      if (dt > 0) {\n        // http://gafferongames.com/game-physics/fix-your-timestep/\n        if (dt > 64) dt = 64;\n        this.updating = true;\n        const springs = this.springs;\n        if (springs.length) [...springs].forEach(spring => {\n          spring.idle || this.advance(dt, spring);\n        }); // Notify frame listeners.\n\n        const queues = this._queues;\n        const queue = queues[0];\n\n        if (queue.size) {\n          // Run and clear the queue.\n          queue.forEach(onFrame => onFrame());\n          queue.clear(); // Swap the queues.\n\n          queues[0] = queues[1];\n          queues[1] = queue;\n        }\n\n        const writes = this._writes;\n\n        if (writes.size) {\n          this.writing = true;\n          writes.forEach(write => write(time));\n          this.writing = false;\n          writes.clear();\n        }\n\n        this.updating = false;\n\n        if (!this.springs.length) {\n          return this.active = false;\n        }\n      }\n\n      this.lastTime = time;\n\n      this._requestFrame(this.update);\n\n      return true;\n    });\n  }\n  /**\r\n   * Schedule a function to run at the end of the current frame,\r\n   * after all springs have been updated.\r\n   *\r\n   * Pass `true` as the 2nd argument to run at the end of the **next** frame.\r\n   */\n\n\n  onFrame(cb, next) {\n    this._queues[next && this.updating ? 1 : 0].add(cb);\n\n    this._start();\n  }\n  /**\r\n   * Schedule a function run at the end of the current frame,\r\n   * after all `onFrame` callbacks have been called.\r\n   *\r\n   * Calling `onWrite` from inside an `onWrite` callback simply\r\n   * calls the nested write immediately.\r\n   */\n\n\n  onWrite(cb) {\n    if (this.writing) {\n      cb(this.lastTime);\n    } else {\n      this._writes.add(cb);\n    }\n  }\n  /**\r\n   * Start animating the given spring.\r\n   *\r\n   * Beware: Never `start` the same spring twice (without `stop` between).\r\n   */\n\n\n  start(spring) {\n    const springs = this.springs;\n    let i = springs.findIndex(s => s.priority > spring.priority);\n    if (i < 0) i = springs.length;\n    springs.splice(i, 0, spring);\n\n    this._start();\n  }\n\n  _start() {\n    if (!this.active) {\n      this.active = true;\n      this.lastTime = performanceNow();\n\n      this._requestFrame(this.update);\n    }\n  }\n  /**\r\n   * Stop animating the given spring\r\n   */\n\n\n  stop(spring) {\n    const springs = this.springs;\n    const i = springs.indexOf(spring);\n    if (~i) springs.splice(i, 1);\n    return this;\n  }\n  /**\r\n   * Advance an animation forward one frame.\r\n   */\n\n\n  advance(dt, spring) {\n    let idle = true;\n    let changed = false;\n    const anim = spring.animation;\n    const parent = isFluidValue(anim.to) && anim.to;\n    const payload = isAnimationValue(parent) && parent.node.getPayload();\n    anim.values.forEach((node, i) => {\n      if (node.done) return;\n      let to = payload ? payload[i].lastPosition : parent ? toArray(parent.get())[i] : anim.toValues[i]; // Parent springs must finish before their children can.\n\n      const canFinish = !payload || payload[i].done; // Jump to end value for immediate animations.\n\n      if (anim.immediate) {\n        node.done = canFinish;\n\n        if (node.setValue(to)) {\n          changed = true;\n        }\n\n        return;\n      }\n\n      const config = anim.config; // Loose springs never move.\n\n      if (config.tension == 0) {\n        node.done = true;\n        return;\n      }\n\n      const elapsed = node.elapsedTime += dt;\n      const from = anim.fromValues[i];\n      const v0 = node.v0 != null ? node.v0 : node.v0 = is.arr(config.velocity) ? config.velocity[i] : config.velocity;\n      let position = node.lastPosition;\n      let velocity;\n      let finished; // Duration easing\n\n      if (!is.und(config.duration)) {\n        let p = config.progress;\n        if (config.duration <= 0) p = 1;else p += (1 - p) * Math.min(1, elapsed / config.duration);\n        position = from + config.easing(p) * (to - from);\n        velocity = (position - node.lastPosition) / dt;\n        finished = p == 1;\n      } // Decay easing\n      else if (config.decay) {\n          const decay = config.decay === true ? 0.998 : config.decay;\n          const e = Math.exp(-(1 - decay) * elapsed);\n          position = from + v0 / (1 - decay) * (1 - e); // derivative of position\n\n          velocity = v0 * e;\n          finished = Math.abs(node.lastPosition - position) < 0.1;\n          if (finished) to = position;\n        } // Spring easing\n        else {\n            velocity = node.lastVelocity == null ? v0 : node.lastVelocity;\n            /** The smallest distance from a value before being treated like said value. */\n\n            const precision = config.precision || (from == to ? 0.005 : Math.min(1, Math.abs(to - from) * 0.001));\n            /** The velocity at which movement is essentially none */\n\n            const restVelocity = config.restVelocity || precision; // Bouncing is opt-in (not to be confused with overshooting)\n\n            const bounceFactor = config.clamp ? 0 : config.bounce;\n            const canBounce = !is.und(bounceFactor);\n            /** When `true`, the value is increasing over time */\n\n            const isGrowing = from == to ? node.v0 > 0 : from < to;\n            /** When `true`, the velocity is considered moving */\n\n            let isMoving;\n            /** When `true`, the velocity is being deflected or clamped */\n\n            let isBouncing = false;\n            const step = 0.05 / config.w0;\n            const numSteps = Math.ceil(dt / step);\n\n            for (let n = 0; n < numSteps; ++n) {\n              isMoving = Math.abs(velocity) > restVelocity;\n\n              if (!isMoving) {\n                finished = Math.abs(to - position) <= precision;\n\n                if (finished) {\n                  break;\n                }\n              }\n\n              if (canBounce) {\n                isBouncing = position == to || position > to == isGrowing; // Invert the velocity with a magnitude, or clamp it.\n\n                if (isBouncing) {\n                  velocity = -velocity * bounceFactor;\n                  position = to;\n                }\n              }\n\n              const springForce = -config.tension * 0.000001 * (position - to);\n              const dampingForce = -config.friction * 0.001 * velocity;\n              const acceleration = (springForce + dampingForce) / config.mass; // pt/ms^2\n\n              velocity = velocity + acceleration * step; // pt/ms\n\n              position = position + velocity * step;\n            }\n          }\n\n      if (Number.isNaN(position)) {\n        throw Error(`Found NaN value while advancing \"${spring.key}\" animation`);\n      }\n\n      if (finished && canFinish) {\n        node.done = true;\n      } else {\n        idle = false;\n      }\n\n      node.lastVelocity = velocity;\n\n      if (node.setValue(position, config.round)) {\n        changed = true;\n      }\n    });\n    spring.onFrame(idle, changed);\n  }\n\n}\n\nGlobals.assign({\n  frameLoop: new FrameLoop(),\n  createStringInterpolator: createStringInterpolator$1,\n  applyAnimatedValues: () => false\n});\n/** Advance all animations forward one frame */\n\nconst update = () => Globals.frameLoop.update();\n\nexport { Controller, FrameLoop, Spring, SpringValue, Trail, Transition, config, interpolate, to, update, useChain, useSpring, useSprings, useTrail, useTransition };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}