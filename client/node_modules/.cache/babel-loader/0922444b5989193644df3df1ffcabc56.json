{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { useGestureResponder } from \"react-gesture-responder\";\nimport { animated, useSpring } from \"react-spring\";\nimport { useMeasure } from \"./use-measure\";\nimport useScrollLock from \"use-scroll-lock\";\nimport { usePrevious } from \"./use-previous\";\n\nvar Pager = function (_a, ref) {\n  var children = _a.children,\n      id = _a.id,\n      providedIndex = _a.value,\n      onRequestChange = _a.onRequestChange,\n      _b = _a.focusOnChange,\n      focusOnChange = _b === void 0 ? false : _b,\n      _c = _a.enableScrollLock,\n      enableScrollLock = _c === void 0 ? true : _c,\n      _d = _a.enableGestures,\n      enableGestures = _d === void 0 ? true : _d,\n      _e = _a.enableMouse,\n      enableMouse = _e === void 0 ? false : _e,\n      _f = _a.lazyLoad,\n      lazyLoad = _f === void 0 ? false : _f,\n      onSetLazy = _a.onSetLazy,\n      _g = _a.animationConfig,\n      animationConfig = _g === void 0 ? {\n    tension: 190,\n    friction: 20,\n    mass: 0.4\n  } : _g,\n      onTerminationRequest = _a.onTerminationRequest,\n      onMoveShouldSet = _a.onMoveShouldSet,\n      style = _a.style,\n      other = tslib_1.__rest(_a, [\"children\", \"id\", \"value\", \"onRequestChange\", \"focusOnChange\", \"enableScrollLock\", \"enableGestures\", \"enableMouse\", \"lazyLoad\", \"onSetLazy\", \"animationConfig\", \"onTerminationRequest\", \"onMoveShouldSet\", \"style\"]);\n\n  var _h = typeof providedIndex === \"number\" ? {\n    immediate: false,\n    index: providedIndex\n  } : providedIndex,\n      immediate = _h.immediate,\n      index = _h.index;\n\n  var containerRef = React.useRef(null);\n\n  var _j = React.useState(false),\n      isDragging = _j[0],\n      setIsDragging = _j[1];\n\n  var _k = React.useState(function () {\n    return new Set(onSetLazy ? onSetLazy(index) : [index]);\n  }),\n      loaded = _k[0],\n      setLoaded = _k[1];\n\n  var width = useMeasure(containerRef).width;\n  var childrenRefs = React.useRef(new Map());\n  var previousIndex = usePrevious(index);\n  var shouldFocusRef = React.useRef(null);\n  useScrollLock(isDragging && enableScrollLock);\n  React.useEffect(function () {\n    if (typeof previousIndex === \"number\" && previousIndex !== index) {\n      shouldFocusRef.current = index;\n    } else {\n      shouldFocusRef.current = null;\n    }\n  }, [previousIndex, index]);\n\n  function focusByIndex(i) {\n    var el = childrenRefs.current.get(i);\n\n    if (el) {\n      el.focus();\n    }\n  } // expose an imperative focus function which focuses\n  // the currently active index\n\n\n  React.useImperativeHandle(ref, function () {\n    return {\n      focus: function (i) {\n        focusByIndex(i || index);\n      }\n    };\n  });\n\n  var _l = useSpring(function () {\n    return {\n      x: index * -100,\n      config: animationConfig\n    };\n  }),\n      x = _l[0].x,\n      set = _l[1];\n  /**\n   * Potentially autofocus after our animation\n   */\n\n\n  function onRest() {\n    if (typeof shouldFocusRef.current === \"number\") {\n      focusByIndex(shouldFocusRef.current);\n    }\n  }\n\n  var renderableChildren = children.filter(function (child) {\n    return child !== null;\n  }); // gesture view counts\n\n  var childCount = renderableChildren.length;\n  var maxIndex = childCount - 1;\n  var minIndex = 0;\n  /**\n   * Prevent invalid indexes\n   */\n\n  function isValidNextIndex(index) {\n    return index > 0 && index <= maxIndex;\n  }\n  /**\n   * We keep a set of indexes that should\n   * be loaded for lazy loading.\n   */\n\n\n  function addIndexToLoaded(index) {\n    if (!isValidNextIndex(index)) {\n      return;\n    }\n\n    var indexes = index; // allow the user to customize which indexes to load\n\n    if (onSetLazy) {\n      indexes = onSetLazy(index);\n    }\n\n    var indexesArray = Array.isArray(indexes) ? indexes : [indexes];\n    var next = new Set(loaded);\n    indexesArray.forEach(function (i) {\n      // don't set items which are already loaded or are invalid\n      if (loaded.has(i) || !isValidNextIndex(index)) {\n        return;\n      }\n\n      next.add(i);\n    });\n    setLoaded(next);\n  } // animate into position if our index changes\n\n\n  React.useEffect(function () {\n    set({\n      x: index * -100,\n      onRest: onRest,\n      immediate: immediate\n    });\n    loaded.add(index);\n  }, [index, immediate]);\n  /**\n   * Handle gesture end event (either touchend\n   * or pan responder termination).\n   */\n\n  function releaseToPosition(x) {\n    // if it's over 50% in either direction, move to that index.\n    // otherwise, snap back to existing index.\n    var threshold = width / 2;\n\n    if (Math.abs(x) > threshold) {\n      if (x < 0 && index < maxIndex) {\n        onRequestChange(index + 1);\n      } else if (x > 0 && index > minIndex) {\n        onRequestChange(index - 1);\n      } else {\n        set({\n          x: index * -100\n        });\n      }\n    } else {\n      // return back!\n      set({\n        x: index * -100,\n        onRest: onRest\n      });\n    }\n  }\n\n  function onTermination(_a) {\n    var delta = _a.delta;\n    setIsDragging(false);\n    releaseToPosition(delta[0]);\n  }\n\n  function onEnd(_a) {\n    var delta = _a.delta,\n        velocity = _a.velocity,\n        direction = _a.direction;\n    var x = delta[0];\n    setIsDragging(false); // 1. If the force is great enough, switch to the previous index\n\n    if (velocity > 0.2 && direction[0] > 0 && index > minIndex) {\n      return onRequestChange(index - 1);\n    } // or the next index, depending on direction\n\n\n    if (velocity > 0.2 && direction[0] < 0 && index < maxIndex) {\n      return onRequestChange(index + 1);\n    }\n\n    releaseToPosition(x);\n  }\n  /**\n   * Observe our pan-responder to enable gestures\n   */\n\n\n  var bind = useGestureResponder({\n    onTerminationRequest: onTerminationRequest,\n    onStartShouldSet: function () {\n      if (!enableGestures) {\n        return false;\n      }\n\n      return false;\n    },\n    onMoveShouldSet: function (state, e) {\n      var xy = state.xy,\n          initialDirection = state.initialDirection;\n\n      if (!enableGestures) {\n        return false;\n      }\n\n      var set = Math.abs(initialDirection[0]) > Math.abs(initialDirection[1]); // allow the user to tap into this component to potentially\n      // override it\n\n      if (onMoveShouldSet) {\n        return onMoveShouldSet(state, e, set);\n      }\n\n      return set;\n    },\n    onGrant: function () {\n      setIsDragging(true);\n    },\n    onMove: function (_a) {\n      var delta = _a.delta,\n          direction = _a.direction;\n      var x = delta[0];\n      var xPos = x / width * 100 + index * -100;\n      set({\n        x: xPos,\n        immediate: true,\n        onRest: function () {}\n      }); // lazy load the item we are swiping towards\n\n      addIndexToLoaded(direction[0] > 0 ? index - 1 : index + 1);\n    },\n    onRelease: onEnd,\n    onTerminate: onTermination\n  }, {\n    uid: id,\n    enableMouse: enableMouse\n  }).bind;\n  return React.createElement(\"div\", tslib_1.__assign({}, bind, {\n    ref: containerRef,\n    className: \"Gesture-view\",\n    style: tslib_1.__assign({\n      display: \"flex\",\n      flexDirection: \"column\",\n      overflow: \"hidden\",\n      width: \"100%\"\n    }, style)\n  }, other), React.createElement(animated.div, {\n    className: \"Gesture-view__animated-container\",\n    style: {\n      flexDirection: \"row\",\n      direction: \"ltr\",\n      willChange: \"transform\",\n      minHeight: 0,\n      flex: 1,\n      display: \"flex\",\n      transform: x.interpolate(function (x) {\n        return \"translateX(\" + taper(x, maxIndex * -100) + \"%)\";\n      })\n    }\n  }, renderableChildren.map(function (child, i) {\n    var styles = {\n      display: \"flex\",\n      flexDirection: \"column\",\n      width: \"100%\",\n      alignSelf: \"stretch\",\n      justifyContent: \"flex-start\",\n      flexShrink: 0,\n      height: \"100%\",\n      overflow: \"hidden\",\n      outline: \"none\"\n    };\n    var props = {\n      key: i,\n      tabIndex: index === i ? 0 : -1,\n      style: styles,\n      \"aria-hidden\": i !== index,\n      ref: function (el) {\n        childrenRefs.current.set(i, el);\n      }\n    };\n    var load = !lazyLoad || index === i || loaded.has(i);\n\n    if (typeof child === \"function\") {\n      return child(props, index === i, load);\n    }\n\n    return React.createElement(\"div\", tslib_1.__assign({\n      className: \"Gesture-view__pane\"\n    }, props), load && child);\n  })));\n};\n\nexport default React.forwardRef(Pager);\n/**\n * Add some resistance when swiping in a direction\n * that doesn't contain another pane\n */\n\nfunction taper(x, maxWidth) {\n  if (x > 0) {\n    return x * 0.3;\n  }\n\n  if (x < maxWidth) {\n    var diff = x - maxWidth;\n    return x - diff * 0.7;\n  }\n\n  return x;\n}","map":{"version":3,"sources":["/home/noahdubs/noah/project/express-n-react/workout-app/client/node_modules/react-page-controller/esm/index.js"],"names":["tslib_1","React","useGestureResponder","animated","useSpring","useMeasure","useScrollLock","usePrevious","Pager","_a","ref","children","id","providedIndex","value","onRequestChange","_b","focusOnChange","_c","enableScrollLock","_d","enableGestures","_e","enableMouse","_f","lazyLoad","onSetLazy","_g","animationConfig","tension","friction","mass","onTerminationRequest","onMoveShouldSet","style","other","__rest","_h","immediate","index","containerRef","useRef","_j","useState","isDragging","setIsDragging","_k","Set","loaded","setLoaded","width","childrenRefs","Map","previousIndex","shouldFocusRef","useEffect","current","focusByIndex","i","el","get","focus","useImperativeHandle","_l","x","config","set","onRest","renderableChildren","filter","child","childCount","length","maxIndex","minIndex","isValidNextIndex","addIndexToLoaded","indexes","indexesArray","Array","isArray","next","forEach","has","add","releaseToPosition","threshold","Math","abs","onTermination","delta","onEnd","velocity","direction","bind","onStartShouldSet","state","e","xy","initialDirection","onGrant","onMove","xPos","onRelease","onTerminate","uid","createElement","__assign","className","display","flexDirection","overflow","div","willChange","minHeight","flex","transform","interpolate","taper","map","styles","alignSelf","justifyContent","flexShrink","height","outline","props","key","tabIndex","load","forwardRef","maxWidth","diff"],"mappings":"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","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { useGestureResponder } from \"react-gesture-responder\";\nimport { animated, useSpring } from \"react-spring\";\nimport { useMeasure } from \"./use-measure\";\nimport useScrollLock from \"use-scroll-lock\";\nimport { usePrevious } from \"./use-previous\";\nvar Pager = function (_a, ref) {\n    var children = _a.children, id = _a.id, providedIndex = _a.value, onRequestChange = _a.onRequestChange, _b = _a.focusOnChange, focusOnChange = _b === void 0 ? false : _b, _c = _a.enableScrollLock, enableScrollLock = _c === void 0 ? true : _c, _d = _a.enableGestures, enableGestures = _d === void 0 ? true : _d, _e = _a.enableMouse, enableMouse = _e === void 0 ? false : _e, _f = _a.lazyLoad, lazyLoad = _f === void 0 ? false : _f, onSetLazy = _a.onSetLazy, _g = _a.animationConfig, animationConfig = _g === void 0 ? { tension: 190, friction: 20, mass: 0.4 } : _g, onTerminationRequest = _a.onTerminationRequest, onMoveShouldSet = _a.onMoveShouldSet, style = _a.style, other = tslib_1.__rest(_a, [\"children\", \"id\", \"value\", \"onRequestChange\", \"focusOnChange\", \"enableScrollLock\", \"enableGestures\", \"enableMouse\", \"lazyLoad\", \"onSetLazy\", \"animationConfig\", \"onTerminationRequest\", \"onMoveShouldSet\", \"style\"]);\n    var _h = typeof providedIndex === \"number\"\n        ? { immediate: false, index: providedIndex }\n        : providedIndex, immediate = _h.immediate, index = _h.index;\n    var containerRef = React.useRef(null);\n    var _j = React.useState(false), isDragging = _j[0], setIsDragging = _j[1];\n    var _k = React.useState(function () { return new Set(onSetLazy ? onSetLazy(index) : [index]); }), loaded = _k[0], setLoaded = _k[1];\n    var width = useMeasure(containerRef).width;\n    var childrenRefs = React.useRef(new Map());\n    var previousIndex = usePrevious(index);\n    var shouldFocusRef = React.useRef(null);\n    useScrollLock(isDragging && enableScrollLock);\n    React.useEffect(function () {\n        if (typeof previousIndex === \"number\" && previousIndex !== index) {\n            shouldFocusRef.current = index;\n        }\n        else {\n            shouldFocusRef.current = null;\n        }\n    }, [previousIndex, index]);\n    function focusByIndex(i) {\n        var el = childrenRefs.current.get(i);\n        if (el) {\n            el.focus();\n        }\n    }\n    // expose an imperative focus function which focuses\n    // the currently active index\n    React.useImperativeHandle(ref, function () { return ({\n        focus: function (i) {\n            focusByIndex(i || index);\n        }\n    }); });\n    var _l = useSpring(function () { return ({\n        x: index * -100,\n        config: animationConfig\n    }); }), x = _l[0].x, set = _l[1];\n    /**\n     * Potentially autofocus after our animation\n     */\n    function onRest() {\n        if (typeof shouldFocusRef.current === \"number\") {\n            focusByIndex(shouldFocusRef.current);\n        }\n    }\n    var renderableChildren = children.filter(function (child) { return child !== null; });\n    // gesture view counts\n    var childCount = renderableChildren.length;\n    var maxIndex = childCount - 1;\n    var minIndex = 0;\n    /**\n     * Prevent invalid indexes\n     */\n    function isValidNextIndex(index) {\n        return index > 0 && index <= maxIndex;\n    }\n    /**\n     * We keep a set of indexes that should\n     * be loaded for lazy loading.\n     */\n    function addIndexToLoaded(index) {\n        if (!isValidNextIndex(index)) {\n            return;\n        }\n        var indexes = index;\n        // allow the user to customize which indexes to load\n        if (onSetLazy) {\n            indexes = onSetLazy(index);\n        }\n        var indexesArray = Array.isArray(indexes) ? indexes : [indexes];\n        var next = new Set(loaded);\n        indexesArray.forEach(function (i) {\n            // don't set items which are already loaded or are invalid\n            if (loaded.has(i) || !isValidNextIndex(index)) {\n                return;\n            }\n            next.add(i);\n        });\n        setLoaded(next);\n    }\n    // animate into position if our index changes\n    React.useEffect(function () {\n        set({\n            x: index * -100,\n            onRest: onRest,\n            immediate: immediate\n        });\n        loaded.add(index);\n    }, [index, immediate]);\n    /**\n     * Handle gesture end event (either touchend\n     * or pan responder termination).\n     */\n    function releaseToPosition(x) {\n        // if it's over 50% in either direction, move to that index.\n        // otherwise, snap back to existing index.\n        var threshold = width / 2;\n        if (Math.abs(x) > threshold) {\n            if (x < 0 && index < maxIndex) {\n                onRequestChange(index + 1);\n            }\n            else if (x > 0 && index > minIndex) {\n                onRequestChange(index - 1);\n            }\n            else {\n                set({ x: index * -100 });\n            }\n        }\n        else {\n            // return back!\n            set({ x: index * -100, onRest: onRest });\n        }\n    }\n    function onTermination(_a) {\n        var delta = _a.delta;\n        setIsDragging(false);\n        releaseToPosition(delta[0]);\n    }\n    function onEnd(_a) {\n        var delta = _a.delta, velocity = _a.velocity, direction = _a.direction;\n        var x = delta[0];\n        setIsDragging(false);\n        // 1. If the force is great enough, switch to the previous index\n        if (velocity > 0.2 && direction[0] > 0 && index > minIndex) {\n            return onRequestChange(index - 1);\n        }\n        // or the next index, depending on direction\n        if (velocity > 0.2 && direction[0] < 0 && index < maxIndex) {\n            return onRequestChange(index + 1);\n        }\n        releaseToPosition(x);\n    }\n    /**\n     * Observe our pan-responder to enable gestures\n     */\n    var bind = useGestureResponder({\n        onTerminationRequest: onTerminationRequest,\n        onStartShouldSet: function () {\n            if (!enableGestures) {\n                return false;\n            }\n            return false;\n        },\n        onMoveShouldSet: function (state, e) {\n            var xy = state.xy, initialDirection = state.initialDirection;\n            if (!enableGestures) {\n                return false;\n            }\n            var set = Math.abs(initialDirection[0]) > Math.abs(initialDirection[1]);\n            // allow the user to tap into this component to potentially\n            // override it\n            if (onMoveShouldSet) {\n                return onMoveShouldSet(state, e, set);\n            }\n            return set;\n        },\n        onGrant: function () {\n            setIsDragging(true);\n        },\n        onMove: function (_a) {\n            var delta = _a.delta, direction = _a.direction;\n            var x = delta[0];\n            var xPos = (x / width) * 100 + index * -100;\n            set({\n                x: xPos,\n                immediate: true,\n                onRest: function () { }\n            });\n            // lazy load the item we are swiping towards\n            addIndexToLoaded(direction[0] > 0 ? index - 1 : index + 1);\n        },\n        onRelease: onEnd,\n        onTerminate: onTermination\n    }, {\n        uid: id,\n        enableMouse: enableMouse\n    }).bind;\n    return (React.createElement(\"div\", tslib_1.__assign({}, bind, { ref: containerRef, className: \"Gesture-view\", style: tslib_1.__assign({ display: \"flex\", flexDirection: \"column\", overflow: \"hidden\", width: \"100%\" }, style) }, other),\n        React.createElement(animated.div, { className: \"Gesture-view__animated-container\", style: {\n                flexDirection: \"row\",\n                direction: \"ltr\",\n                willChange: \"transform\",\n                minHeight: 0,\n                flex: 1,\n                display: \"flex\",\n                transform: x.interpolate(function (x) { return \"translateX(\" + taper(x, maxIndex * -100) + \"%)\"; })\n            } }, renderableChildren.map(function (child, i) {\n            var styles = {\n                display: \"flex\",\n                flexDirection: \"column\",\n                width: \"100%\",\n                alignSelf: \"stretch\",\n                justifyContent: \"flex-start\",\n                flexShrink: 0,\n                height: \"100%\",\n                overflow: \"hidden\",\n                outline: \"none\"\n            };\n            var props = {\n                key: i,\n                tabIndex: index === i ? 0 : -1,\n                style: styles,\n                \"aria-hidden\": i !== index,\n                ref: function (el) {\n                    childrenRefs.current.set(i, el);\n                }\n            };\n            var load = !lazyLoad || index === i || loaded.has(i);\n            if (typeof child === \"function\") {\n                return child(props, index === i, load);\n            }\n            return (React.createElement(\"div\", tslib_1.__assign({ className: \"Gesture-view__pane\" }, props), load && child));\n        }))));\n};\nexport default React.forwardRef(Pager);\n/**\n * Add some resistance when swiping in a direction\n * that doesn't contain another pane\n */\nfunction taper(x, maxWidth) {\n    if (x > 0) {\n        return x * 0.3;\n    }\n    if (x < maxWidth) {\n        var diff = x - maxWidth;\n        return x - diff * 0.7;\n    }\n    return x;\n}\n"]},"metadata":{},"sourceType":"module"}