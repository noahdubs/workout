{"ast":null,"code":"import { defineHidden, FluidType, is, each, isFluidValue, createInterpolator, toArray, isEqual, Globals, needsInterpolation, useForceUpdate, useIsomorphicLayoutEffect } from '@react-spring/shared';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { deprecateInterpolate } from '@react-spring/shared/deprecations';\nimport { to, createAnimatedTransform, createAnimatedStyle, frameLoop, applyAnimatedValues, getComponentProps } from '@react-spring/shared/globals';\nimport { createInterpolator as createInterpolator$1, is as is$1 } from '@react-spring/shared';\nimport React, { forwardRef, useRef } from 'react';\nconst AnimatedType = '__$AnimatedType';\n/** Returns true for `Animated` nodes. Returns false for `SpringValue` objects. */\n\nconst isAnimated = value => !!(value && value[AnimatedType]);\n\nclass Animated {\n  constructor() {\n    defineHidden(this, AnimatedType, 1);\n  }\n  /** Returns every animated number used by this node. */\n\n\n  getPayload() {\n    return this.payload || [];\n  }\n\n}\n/** The `AnimatedProps` class sets this before initializing */\n\n\nAnimated.context = null;\n\nconst isAnimationValue = value => (value && value[FluidType]) == 2;\n\nlet nextId = 1;\n/**\r\n * A kind of `FluidValue` that manages an `AnimatedValue` node.\r\n *\r\n * Its underlying value can be accessed and even observed.\r\n */\n\nclass AnimationValue {\n  constructor(key) {\n    this.key = key;\n    this.id = nextId++;\n    this._priority = 0;\n    this._children = new Set();\n    defineHidden(this, FluidType, 2);\n  }\n  /** @internal Controls the order in which animations are updated */\n\n\n  get priority() {\n    return this._priority;\n  }\n\n  set priority(priority) {\n    if (this._priority != priority) {\n      this._priority = priority;\n\n      this._onPriorityChange(priority);\n    }\n  }\n  /** Get the current value */\n\n\n  get() {\n    // The node doesn't exist until the first update, which normally isn't an\n    // issue but it can be for tests.\n    return this.node && this.node.getValue();\n  }\n  /** Create a spring that maps our value to another value */\n\n\n  to() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return to(this, args);\n  }\n  /** @deprecated Use the `to` method instead. */\n\n\n  interpolate() {\n    deprecateInterpolate();\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return to(this, args);\n  }\n  /** @internal */\n\n\n  addChild(child) {\n    if (!this._children.size) this._attach();\n\n    this._children.add(child);\n  }\n  /** @internal */\n\n\n  removeChild(child) {\n    this._children.delete(child);\n\n    if (!this._children.size) this._detach();\n  }\n  /** @internal */\n\n\n  onParentPriorityChange(priority, _parent) {\n    // Assume we only have one parent.\n    this.priority = priority + 1;\n  }\n\n  _attach() {}\n\n  _detach() {}\n  /** Notify observers of a change to our value */\n\n\n  _onChange(value, idle) {\n    if (idle === void 0) {\n      idle = false;\n    } // Clone \"_children\" so it can be safely mutated by the loop.\n\n\n    for (const observer of Array.from(this._children)) {\n      if (is.fun(observer)) {\n        observer(value, this);\n      } else {\n        observer.onParentChange(value, idle, this);\n      }\n    }\n  }\n  /** Notify observers of a change to our priority */\n\n\n  _onPriorityChange(priority) {\n    each(this._children, observer => {\n      if (!is.fun(observer)) {\n        observer.onParentPriorityChange(priority, this);\n      }\n    });\n  }\n  /** Reset our node and the nodes of every descendant */\n\n\n  _reset(goal) {\n    this.node.reset(!this.idle, goal);\n    each(this._children, observer => {\n      if (isAnimationValue(observer)) {\n        observer._reset(goal);\n      }\n    });\n  }\n\n}\n/** An object containing `Animated` nodes */\n\n\nclass AnimatedObject extends Animated {\n  constructor(source) {\n    if (source === void 0) {\n      source = null;\n    }\n\n    super();\n    this.setValue(source);\n  }\n\n  getValue(animated) {\n    if (!this.source) return null;\n    const values = {};\n    each(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else if (isFluidValue(source)) {\n        values[key] = source.get();\n      } else if (!animated) {\n        values[key] = source;\n      }\n    });\n    return values;\n  }\n  /** Replace the raw object data */\n\n\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n\n  reset(isActive, _goal) {\n    if (this.payload) {\n      each(this.payload, node => node.reset(isActive));\n    }\n  }\n  /** Create a payload set. */\n\n\n  _makePayload(source) {\n    if (source) {\n      const payload = new Set();\n      each(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n  /** Add to a payload set. */\n\n\n  _addToPayload(source) {\n    if (isFluidValue(source)) {\n      if (Animated.context) {\n        Animated.context.dependencies.add(source);\n      }\n\n      if (isAnimationValue(source)) {\n        source = source.node;\n      }\n    }\n\n    if (isAnimated(source)) {\n      each(source.getPayload(), node => this.add(node));\n    }\n  }\n\n}\n\nclass AnimatedStyle extends AnimatedObject {\n  constructor(style) {\n    super(style || null);\n  }\n\n  setValue(style) {\n    super.setValue(style && style.transform && createAnimatedTransform ? _extends({}, style, {\n      transform: createAnimatedTransform(style.transform)\n    }) : style);\n  }\n\n}\n/** An animated number or a native attribute value */\n\n\nclass AnimatedValue extends Animated {\n  constructor(_value) {\n    super();\n    this._value = _value;\n    this.done = true;\n\n    if (is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n\n  static create(from, _to) {\n    return new AnimatedValue(from);\n  }\n\n  getPayload() {\n    return [this];\n  }\n\n  getValue() {\n    return this._value;\n  }\n  /**\r\n   * Set the current value and optionally round it.\r\n   *\r\n   * The `step` argument does nothing whenever it equals `undefined` or `0`.\r\n   * It works with fractions and whole numbers. The best use case is (probably)\r\n   * rounding to the pixel grid with a step of:\r\n   *\r\n   *      1 / window.devicePixelRatio\r\n   */\n\n\n  setValue(value, step) {\n    if (is.num(value)) {\n      this.lastPosition = value;\n\n      if (step) {\n        value = Math.round(value / step) * step;\n\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n\n    if (this._value === value) {\n      return false;\n    }\n\n    this._value = value;\n    return true;\n  }\n\n  reset(isActive, _goal) {\n    this.done = false;\n\n    if (is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.lastPosition = this._value;\n      if (!isActive) this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n\n}\n/**\r\n * `Into` springs are memoized interpolators that react to their dependencies.\r\n *  The memoized result is updated whenever a dependency changes.\r\n */\n\n\nclass Into extends AnimationValue {\n  constructor(\n  /** The source of input values */\n  source, args) {\n    super();\n    this.source = source;\n    this.calc = createInterpolator(...args);\n    this.node = new AnimatedValue(this._compute());\n  }\n\n  get idle() {\n    return this.node.done;\n  }\n\n  _compute() {\n    const inputs = is.arr(this.source) ? this.source.map(node => node.get()) : toArray(this.source.get());\n    return this.calc(...inputs);\n  }\n\n  _attach() {\n    // Start observing our \"source\" once we have an observer.\n    let priority = 0;\n    each(toArray(this.source), source => {\n      priority = Math.max(priority, (source.priority || 0) + 1);\n      source.addChild(this);\n    });\n    this.priority = priority;\n  }\n\n  _detach() {\n    // Stop observing our \"source\" once we have no observers.\n    each(toArray(this.source), source => {\n      source.removeChild(this);\n    });\n  }\n  /** @internal */\n\n\n  onParentChange(_value, idle) {\n    const node = this.node;\n\n    if (idle && !node.done) {\n      // We're not idle until every source is idle.\n      node.done = toArray(this.source).every(source => !isAnimationValue(source) || source.idle);\n    } // TODO: only compute once per frame (note: we'll need to call \"onParentChange\")\n\n\n    const value = this._compute();\n\n    if (!isEqual(value, this.get())) {\n      node.setValue(value);\n\n      this._onChange(value, node.done);\n    }\n  }\n  /** @internal */\n\n\n  onParentPriorityChange(_priority) {\n    // Set our priority to 1 + the highest parent.\n    this.priority = toArray(this.source).reduce((max, source) => Math.max(max, (source.priority || 0) + 1), 0);\n  }\n\n}\n\nGlobals.assign({\n  to: (source, args) => new Into(source, args),\n  createAnimatedStyle: style => new AnimatedStyle(style)\n});\n\nclass AnimatedString extends AnimatedValue {\n  constructor(from, to) {\n    super(0);\n    this._string = null;\n    this._toString = createInterpolator$1({\n      output: [from, to]\n    });\n  }\n\n  static create(from, to) {\n    if (to === void 0) {\n      to = from;\n    }\n\n    if (is$1.str(from) && is$1.str(to)) {\n      return new AnimatedString(from, to);\n    }\n\n    throw TypeError('Expected \"from\" and \"to\" to be strings');\n  }\n\n  getValue() {\n    let value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n\n  setValue(value) {\n    if (!is$1.num(value)) {\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  reset(isActive, goal) {\n    if (goal) {\n      this._toString = createInterpolator$1({\n        output: [this.getValue(), goal]\n      });\n    }\n\n    this._value = 0;\n    super.reset(isActive);\n  }\n\n}\n/** An array of animated nodes */\n\n\nclass AnimatedArray extends AnimatedObject {\n  constructor(from, to) {\n    super(null);\n    super.setValue(this._makeAnimated(from, to));\n  }\n\n  static create(from, to) {\n    return new AnimatedArray(from, to);\n  }\n\n  getValue() {\n    return this.source.map(node => node.getValue());\n  }\n\n  setValue(newValue) {\n    const payload = this.getPayload(); // Reuse the payload when lengths are equal.\n\n    if (newValue && newValue.length == payload.length) {\n      each(payload, (node, i) => node.setValue(newValue[i]));\n    } else {\n      // Remake the payload when length changes.\n      this.source = this._makeAnimated(newValue);\n      this.payload = this._makePayload(this.source);\n    }\n  }\n  /** Convert the `from` and `to` values to an array of `Animated` nodes */\n\n\n  _makeAnimated(from, to) {\n    if (to === void 0) {\n      to = from;\n    }\n\n    return from ? from.map((from, i) => (needsInterpolation(from) ? AnimatedString : AnimatedValue).create(from, to[i])) : [];\n  }\n\n}\n\nclass AnimatedProps extends AnimatedObject {\n  constructor(update) {\n    super(null);\n    this.update = update;\n    /** Equals true when a re-render is scheduled for \"end of frame\" */\n\n    this.dirty = false;\n  }\n\n  setValue(props, context) {\n    if (!props) return; // The constructor passes null.\n\n    if (context) {\n      Animated.context = context;\n    }\n\n    super.setValue(props.style && createAnimatedStyle ? _extends({}, props, {\n      style: createAnimatedStyle(props.style)\n    }) : props);\n    Animated.context = null;\n  }\n  /** @internal */\n\n\n  onParentChange() {\n    if (!this.dirty) {\n      this.dirty = true;\n      frameLoop.onFrame(() => {\n        this.dirty = false;\n        this.update();\n      });\n    }\n  }\n  /** @internal */\n\n\n  onParentPriorityChange() {}\n\n}\n\nconst cacheKey = Symbol.for('AnimatedComponent');\n\nconst withAnimated = Component => is.str(Component) ? createAnimatedComponent(Component) : Component[cacheKey] || (Component[cacheKey] = createAnimatedComponent(Component));\n\nconst createAnimatedComponent = Component => forwardRef((rawProps, ref) => {\n  const instanceRef = useRef(null);\n  const hasInstance = // Function components must use \"forwardRef\" to avoid being\n  // re-rendered on every animation frame.\n  !is.fun(Component) || Component.prototype.isReactComponent;\n  const forceUpdate = useForceUpdate();\n  const props = new AnimatedProps(() => {\n    const instance = instanceRef.current;\n\n    if (hasInstance && !instance) {\n      return; // The wrapped component forgot to forward its ref.\n    }\n\n    const didUpdate = instance ? applyAnimatedValues(instance, props.getValue(true)) : false; // Re-render the component when native updates fail.\n\n    if (didUpdate === false) {\n      forceUpdate();\n    }\n  });\n  const dependencies = new Set();\n  props.setValue(rawProps, {\n    dependencies\n  });\n  useIsomorphicLayoutEffect(() => {\n    each(dependencies, dep => dep.addChild(props));\n    return () => each(dependencies, dep => dep.removeChild(props));\n  });\n  return React.createElement(Component, Object.assign({}, getComponentProps(props.getValue()), {\n    ref: hasInstance && (value => {\n      instanceRef.current = updateRef(ref, value);\n    })\n  }));\n});\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n}\n/**\r\n * Pass the given components to `withAnimated` and add the newly animated\r\n * components to `withAnimated` as properties.\r\n */\n\n\nconst extendAnimated = (withAnimated, components, lowercase) => {\n  components.forEach(Component => {\n    let key = getDisplayName(Component);\n\n    if (lowercase) {\n      key = key[0].toLowerCase() + key.slice(1);\n    }\n\n    withAnimated[key] = withAnimated(Component);\n  });\n  return withAnimated;\n};\n\nconst getDisplayName = arg => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedProps, AnimatedString, AnimatedStyle, AnimatedType, AnimatedValue, AnimationValue, Into, extendAnimated, isAnimated, isAnimationValue, withAnimated };","map":{"version":3,"sources":["src/Animated.ts","src/AnimationValue.ts","src/AnimatedObject.ts","src/AnimatedStyle.ts","src/AnimatedValue.ts","src/Into.ts","src/globals.ts","src/AnimatedString.ts","src/AnimatedArray.ts","src/AnimatedProps.ts","src/withAnimated.tsx"],"names":["AnimatedType","isAnimated","value","Animated","constructor","defineHidden","getPayload","isAnimationValue","nextId","AnimationValue","get","to","args","G","interpolate","deprecateInterpolate","addChild","removeChild","onParentPriorityChange","priority","_attach","_detach","_onChange","idle","Array","is","observer","_onPriorityChange","each","_reset","AnimatedObject","source","getValue","values","isFluidValue","setValue","reset","node","_makePayload","payload","_addToPayload","AnimatedStyle","style","transform","AnimatedValue","_value","Math","Into","createInterpolator","_compute","inputs","toArray","onParentChange","isEqual","Globals","createAnimatedStyle","AnimatedString","from","output","TypeError","AnimatedArray","newValue","_makeAnimated","needsInterpolation","AnimatedProps","update","props","cacheKey","Symbol","withAnimated","Component","createAnimatedComponent","forwardRef","instanceRef","useRef","hasInstance","forceUpdate","useForceUpdate","instance","didUpdate","dependencies","useIsomorphicLayoutEffect","dep","ref","updateRef","extendAnimated","components","key","getDisplayName","arg"],"mappings":"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","sourcesContent":["import { defineHidden, FluidType, is, each, isFluidValue, createInterpolator, toArray, isEqual, Globals, needsInterpolation, useForceUpdate, useIsomorphicLayoutEffect } from '@react-spring/shared';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { deprecateInterpolate } from '@react-spring/shared/deprecations';\nimport { to, createAnimatedTransform, createAnimatedStyle, frameLoop, applyAnimatedValues, getComponentProps } from '@react-spring/shared/globals';\nimport { createInterpolator as createInterpolator$1, is as is$1 } from '@react-spring/shared';\nimport React, { forwardRef, useRef } from 'react';\n\nconst AnimatedType = '__$AnimatedType';\n/** Returns true for `Animated` nodes. Returns false for `SpringValue` objects. */\n\nconst isAnimated = value => !!(value && value[AnimatedType]);\nclass Animated {\n  constructor() {\n    defineHidden(this, AnimatedType, 1);\n  }\n  /** Returns every animated number used by this node. */\n\n\n  getPayload() {\n    return this.payload || [];\n  }\n\n}\n/** The `AnimatedProps` class sets this before initializing */\n\nAnimated.context = null;\n\nconst isAnimationValue = value => (value && value[FluidType]) == 2;\nlet nextId = 1;\n/**\r\n * A kind of `FluidValue` that manages an `AnimatedValue` node.\r\n *\r\n * Its underlying value can be accessed and even observed.\r\n */\n\nclass AnimationValue {\n  constructor(key) {\n    this.key = key;\n    this.id = nextId++;\n    this._priority = 0;\n    this._children = new Set();\n    defineHidden(this, FluidType, 2);\n  }\n  /** @internal Controls the order in which animations are updated */\n\n\n  get priority() {\n    return this._priority;\n  }\n\n  set priority(priority) {\n    if (this._priority != priority) {\n      this._priority = priority;\n\n      this._onPriorityChange(priority);\n    }\n  }\n  /** Get the current value */\n\n\n  get() {\n    // The node doesn't exist until the first update, which normally isn't an\n    // issue but it can be for tests.\n    return this.node && this.node.getValue();\n  }\n  /** Create a spring that maps our value to another value */\n\n\n  to() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return to(this, args);\n  }\n  /** @deprecated Use the `to` method instead. */\n\n\n  interpolate() {\n    deprecateInterpolate();\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return to(this, args);\n  }\n  /** @internal */\n\n\n  addChild(child) {\n    if (!this._children.size) this._attach();\n\n    this._children.add(child);\n  }\n  /** @internal */\n\n\n  removeChild(child) {\n    this._children.delete(child);\n\n    if (!this._children.size) this._detach();\n  }\n  /** @internal */\n\n\n  onParentPriorityChange(priority, _parent) {\n    // Assume we only have one parent.\n    this.priority = priority + 1;\n  }\n\n  _attach() {}\n\n  _detach() {}\n  /** Notify observers of a change to our value */\n\n\n  _onChange(value, idle) {\n    if (idle === void 0) {\n      idle = false;\n    }\n\n    // Clone \"_children\" so it can be safely mutated by the loop.\n    for (const observer of Array.from(this._children)) {\n      if (is.fun(observer)) {\n        observer(value, this);\n      } else {\n        observer.onParentChange(value, idle, this);\n      }\n    }\n  }\n  /** Notify observers of a change to our priority */\n\n\n  _onPriorityChange(priority) {\n    each(this._children, observer => {\n      if (!is.fun(observer)) {\n        observer.onParentPriorityChange(priority, this);\n      }\n    });\n  }\n  /** Reset our node and the nodes of every descendant */\n\n\n  _reset(goal) {\n    this.node.reset(!this.idle, goal);\n    each(this._children, observer => {\n      if (isAnimationValue(observer)) {\n        observer._reset(goal);\n      }\n    });\n  }\n\n}\n\n/** An object containing `Animated` nodes */\n\nclass AnimatedObject extends Animated {\n  constructor(source) {\n    if (source === void 0) {\n      source = null;\n    }\n\n    super();\n    this.setValue(source);\n  }\n\n  getValue(animated) {\n    if (!this.source) return null;\n    const values = {};\n    each(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else if (isFluidValue(source)) {\n        values[key] = source.get();\n      } else if (!animated) {\n        values[key] = source;\n      }\n    });\n    return values;\n  }\n  /** Replace the raw object data */\n\n\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n\n  reset(isActive, _goal) {\n    if (this.payload) {\n      each(this.payload, node => node.reset(isActive));\n    }\n  }\n  /** Create a payload set. */\n\n\n  _makePayload(source) {\n    if (source) {\n      const payload = new Set();\n      each(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n  /** Add to a payload set. */\n\n\n  _addToPayload(source) {\n    if (isFluidValue(source)) {\n      if (Animated.context) {\n        Animated.context.dependencies.add(source);\n      }\n\n      if (isAnimationValue(source)) {\n        source = source.node;\n      }\n    }\n\n    if (isAnimated(source)) {\n      each(source.getPayload(), node => this.add(node));\n    }\n  }\n\n}\n\nclass AnimatedStyle extends AnimatedObject {\n  constructor(style) {\n    super(style || null);\n  }\n\n  setValue(style) {\n    super.setValue(style && style.transform && createAnimatedTransform ? _extends({}, style, {\n      transform: createAnimatedTransform(style.transform)\n    }) : style);\n  }\n\n}\n\n/** An animated number or a native attribute value */\n\nclass AnimatedValue extends Animated {\n  constructor(_value) {\n    super();\n    this._value = _value;\n    this.done = true;\n\n    if (is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n\n  static create(from, _to) {\n    return new AnimatedValue(from);\n  }\n\n  getPayload() {\n    return [this];\n  }\n\n  getValue() {\n    return this._value;\n  }\n  /**\r\n   * Set the current value and optionally round it.\r\n   *\r\n   * The `step` argument does nothing whenever it equals `undefined` or `0`.\r\n   * It works with fractions and whole numbers. The best use case is (probably)\r\n   * rounding to the pixel grid with a step of:\r\n   *\r\n   *      1 / window.devicePixelRatio\r\n   */\n\n\n  setValue(value, step) {\n    if (is.num(value)) {\n      this.lastPosition = value;\n\n      if (step) {\n        value = Math.round(value / step) * step;\n\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n\n    if (this._value === value) {\n      return false;\n    }\n\n    this._value = value;\n    return true;\n  }\n\n  reset(isActive, _goal) {\n    this.done = false;\n\n    if (is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.lastPosition = this._value;\n      if (!isActive) this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n\n}\n\n/**\r\n * `Into` springs are memoized interpolators that react to their dependencies.\r\n *  The memoized result is updated whenever a dependency changes.\r\n */\n\nclass Into extends AnimationValue {\n  constructor(\n  /** The source of input values */\n  source, args) {\n    super();\n    this.source = source;\n    this.calc = createInterpolator(...args);\n    this.node = new AnimatedValue(this._compute());\n  }\n\n  get idle() {\n    return this.node.done;\n  }\n\n  _compute() {\n    const inputs = is.arr(this.source) ? this.source.map(node => node.get()) : toArray(this.source.get());\n    return this.calc(...inputs);\n  }\n\n  _attach() {\n    // Start observing our \"source\" once we have an observer.\n    let priority = 0;\n    each(toArray(this.source), source => {\n      priority = Math.max(priority, (source.priority || 0) + 1);\n      source.addChild(this);\n    });\n    this.priority = priority;\n  }\n\n  _detach() {\n    // Stop observing our \"source\" once we have no observers.\n    each(toArray(this.source), source => {\n      source.removeChild(this);\n    });\n  }\n  /** @internal */\n\n\n  onParentChange(_value, idle) {\n    const node = this.node;\n\n    if (idle && !node.done) {\n      // We're not idle until every source is idle.\n      node.done = toArray(this.source).every(source => !isAnimationValue(source) || source.idle);\n    } // TODO: only compute once per frame (note: we'll need to call \"onParentChange\")\n\n\n    const value = this._compute();\n\n    if (!isEqual(value, this.get())) {\n      node.setValue(value);\n\n      this._onChange(value, node.done);\n    }\n  }\n  /** @internal */\n\n\n  onParentPriorityChange(_priority) {\n    // Set our priority to 1 + the highest parent.\n    this.priority = toArray(this.source).reduce((max, source) => Math.max(max, (source.priority || 0) + 1), 0);\n  }\n\n}\n\nGlobals.assign({\n  to: (source, args) => new Into(source, args),\n  createAnimatedStyle: style => new AnimatedStyle(style)\n});\n\nclass AnimatedString extends AnimatedValue {\n  constructor(from, to) {\n    super(0);\n    this._string = null;\n    this._toString = createInterpolator$1({\n      output: [from, to]\n    });\n  }\n\n  static create(from, to) {\n    if (to === void 0) {\n      to = from;\n    }\n\n    if (is$1.str(from) && is$1.str(to)) {\n      return new AnimatedString(from, to);\n    }\n\n    throw TypeError('Expected \"from\" and \"to\" to be strings');\n  }\n\n  getValue() {\n    let value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n\n  setValue(value) {\n    if (!is$1.num(value)) {\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  reset(isActive, goal) {\n    if (goal) {\n      this._toString = createInterpolator$1({\n        output: [this.getValue(), goal]\n      });\n    }\n\n    this._value = 0;\n    super.reset(isActive);\n  }\n\n}\n\n/** An array of animated nodes */\n\nclass AnimatedArray extends AnimatedObject {\n  constructor(from, to) {\n    super(null);\n    super.setValue(this._makeAnimated(from, to));\n  }\n\n  static create(from, to) {\n    return new AnimatedArray(from, to);\n  }\n\n  getValue() {\n    return this.source.map(node => node.getValue());\n  }\n\n  setValue(newValue) {\n    const payload = this.getPayload(); // Reuse the payload when lengths are equal.\n\n    if (newValue && newValue.length == payload.length) {\n      each(payload, (node, i) => node.setValue(newValue[i]));\n    } else {\n      // Remake the payload when length changes.\n      this.source = this._makeAnimated(newValue);\n      this.payload = this._makePayload(this.source);\n    }\n  }\n  /** Convert the `from` and `to` values to an array of `Animated` nodes */\n\n\n  _makeAnimated(from, to) {\n    if (to === void 0) {\n      to = from;\n    }\n\n    return from ? from.map((from, i) => (needsInterpolation(from) ? AnimatedString : AnimatedValue).create(from, to[i])) : [];\n  }\n\n}\n\nclass AnimatedProps extends AnimatedObject {\n  constructor(update) {\n    super(null);\n    this.update = update;\n    /** Equals true when a re-render is scheduled for \"end of frame\" */\n\n    this.dirty = false;\n  }\n\n  setValue(props, context) {\n    if (!props) return; // The constructor passes null.\n\n    if (context) {\n      Animated.context = context;\n    }\n\n    super.setValue(props.style && createAnimatedStyle ? _extends({}, props, {\n      style: createAnimatedStyle(props.style)\n    }) : props);\n    Animated.context = null;\n  }\n  /** @internal */\n\n\n  onParentChange() {\n    if (!this.dirty) {\n      this.dirty = true;\n      frameLoop.onFrame(() => {\n        this.dirty = false;\n        this.update();\n      });\n    }\n  }\n  /** @internal */\n\n\n  onParentPriorityChange() {}\n\n}\n\nconst cacheKey = Symbol.for('AnimatedComponent');\nconst withAnimated = Component => is.str(Component) ? createAnimatedComponent(Component) : Component[cacheKey] || (Component[cacheKey] = createAnimatedComponent(Component));\n\nconst createAnimatedComponent = Component => forwardRef((rawProps, ref) => {\n  const instanceRef = useRef(null);\n  const hasInstance = // Function components must use \"forwardRef\" to avoid being\n  // re-rendered on every animation frame.\n  !is.fun(Component) || Component.prototype.isReactComponent;\n  const forceUpdate = useForceUpdate();\n  const props = new AnimatedProps(() => {\n    const instance = instanceRef.current;\n\n    if (hasInstance && !instance) {\n      return; // The wrapped component forgot to forward its ref.\n    }\n\n    const didUpdate = instance ? applyAnimatedValues(instance, props.getValue(true)) : false; // Re-render the component when native updates fail.\n\n    if (didUpdate === false) {\n      forceUpdate();\n    }\n  });\n  const dependencies = new Set();\n  props.setValue(rawProps, {\n    dependencies\n  });\n  useIsomorphicLayoutEffect(() => {\n    each(dependencies, dep => dep.addChild(props));\n    return () => each(dependencies, dep => dep.removeChild(props));\n  });\n  return React.createElement(Component, Object.assign({}, getComponentProps(props.getValue()), {\n    ref: hasInstance && (value => {\n      instanceRef.current = updateRef(ref, value);\n    })\n  }));\n});\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n}\n/**\r\n * Pass the given components to `withAnimated` and add the newly animated\r\n * components to `withAnimated` as properties.\r\n */\n\n\nconst extendAnimated = (withAnimated, components, lowercase) => {\n  components.forEach(Component => {\n    let key = getDisplayName(Component);\n\n    if (lowercase) {\n      key = key[0].toLowerCase() + key.slice(1);\n    }\n\n    withAnimated[key] = withAnimated(Component);\n  });\n  return withAnimated;\n};\n\nconst getDisplayName = arg => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedProps, AnimatedString, AnimatedStyle, AnimatedType, AnimatedValue, AnimationValue, Into, extendAnimated, isAnimated, isAnimationValue, withAnimated };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}